// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_FLATBUFFNS_PARQUET2_H_
#define FLATBUFFERS_GENERATED_FLATBUFFNS_PARQUET2_H_

#include "flatbuffers/flatbuffers.h"

namespace parquet2 {

struct Value;
struct ValueBuilder;

struct Statistics;
struct StatisticsBuilder;

struct StringType;
struct StringTypeBuilder;

struct UUIDType;
struct UUIDTypeBuilder;

struct MapType;
struct MapTypeBuilder;

struct ListType;
struct ListTypeBuilder;

struct EnumType;
struct EnumTypeBuilder;

struct DateType;
struct DateTypeBuilder;

struct NullType;
struct NullTypeBuilder;

struct DecimalType;
struct DecimalTypeBuilder;

struct MilliSeconds;
struct MilliSecondsBuilder;

struct MicroSeconds;
struct MicroSecondsBuilder;

struct NanoSeconds;
struct NanoSecondsBuilder;

struct TimestampType;
struct TimestampTypeBuilder;

struct TimeType;
struct TimeTypeBuilder;

struct IntType;
struct IntTypeBuilder;

struct JsonType;
struct JsonTypeBuilder;

struct BsonType;
struct BsonTypeBuilder;

struct SchemaElement;
struct SchemaElementBuilder;

struct DataPageHeader;
struct DataPageHeaderBuilder;

struct IndexPageHeader;
struct IndexPageHeaderBuilder;

struct DictionaryPageHeader;
struct DictionaryPageHeaderBuilder;

struct DataPageHeaderV2;
struct DataPageHeaderV2Builder;

struct SplitBlockAlgorithm;
struct SplitBlockAlgorithmBuilder;

struct XxHash;
struct XxHashBuilder;

struct Uncompressed;
struct UncompressedBuilder;

struct BloomFilterHeader;
struct BloomFilterHeaderBuilder;

struct PageHeader;
struct PageHeaderBuilder;

struct KeyValue;
struct KeyValueBuilder;

struct SortingColumn;
struct SortingColumnBuilder;

struct PageEncodingStats;
struct PageEncodingStatsBuilder;

struct ColumnMetadata;
struct ColumnMetadataBuilder;

struct EncryptionWithFooterKey;
struct EncryptionWithFooterKeyBuilder;

struct EncryptionWithColumnKey;
struct EncryptionWithColumnKeyBuilder;

struct ColumnChunk;
struct ColumnChunkBuilder;

struct RowGroup;
struct RowGroupBuilder;

struct TypeDefinedOrder;
struct TypeDefinedOrderBuilder;

struct PageLocation;
struct PageLocationBuilder;

struct OffsetIndex;
struct OffsetIndexBuilder;

struct ColumnIndex;
struct ColumnIndexBuilder;

struct AesGcmV1;
struct AesGcmV1Builder;

struct AesGcmCtrV1;
struct AesGcmCtrV1Builder;

struct FileMetaData;
struct FileMetaDataBuilder;

struct FileCryptoMetaData;
struct FileCryptoMetaDataBuilder;

enum Type {
  Type_UNSET = -1,
  Type_BOOLEAN = 0,
  Type_INT32 = 1,
  Type_INT64 = 2,
  Type_INT96 = 3,
  Type_FLOAT = 4,
  Type_DOUBLE = 5,
  Type_BYTE_ARRAY = 6,
  Type_FIXED_LEN_BYTE_ARRAY = 7,
  Type_MIN = Type_UNSET,
  Type_MAX = Type_FIXED_LEN_BYTE_ARRAY
};

inline const Type (&EnumValuesType())[9] {
  static const Type values[] = {
    Type_UNSET,
    Type_BOOLEAN,
    Type_INT32,
    Type_INT64,
    Type_INT96,
    Type_FLOAT,
    Type_DOUBLE,
    Type_BYTE_ARRAY,
    Type_FIXED_LEN_BYTE_ARRAY
  };
  return values;
}

inline const char * const *EnumNamesType() {
  static const char * const names[10] = {
    "UNSET",
    "BOOLEAN",
    "INT32",
    "INT64",
    "INT96",
    "FLOAT",
    "DOUBLE",
    "BYTE_ARRAY",
    "FIXED_LEN_BYTE_ARRAY",
    nullptr
  };
  return names;
}

inline const char *EnumNameType(Type e) {
  if (flatbuffers::IsOutRange(e, Type_UNSET, Type_FIXED_LEN_BYTE_ARRAY)) return "";
  const size_t index = static_cast<size_t>(e) - static_cast<size_t>(Type_UNSET);
  return EnumNamesType()[index];
}

enum ConvertedType {
  ConvertedType_UNSET = -1,
  ConvertedType_UTF8 = 0,
  ConvertedType_MAP = 1,
  ConvertedType_MAP_KEY_VALUE = 2,
  ConvertedType_LIST = 3,
  ConvertedType_ENUM = 4,
  ConvertedType_DECIMAL = 5,
  ConvertedType_DATE = 6,
  ConvertedType_TIME_MILLIS = 7,
  ConvertedType_TIME_MICROS = 8,
  ConvertedType_TIMESTAMP_MILLIS = 9,
  ConvertedType_TIMESTAMP_MICROS = 10,
  ConvertedType_UINT_8 = 11,
  ConvertedType_UINT_16 = 12,
  ConvertedType_UINT_32 = 13,
  ConvertedType_UINT64 = 14,
  ConvertedType_INT_8 = 15,
  ConvertedType_INT_16 = 16,
  ConvertedType_INT_32 = 17,
  ConvertedType_INT_64 = 18,
  ConvertedType_JSON = 19,
  ConvertedType_BSON = 20,
  ConvertedType_INTERVAL = 21,
  ConvertedType_MIN = ConvertedType_UNSET,
  ConvertedType_MAX = ConvertedType_INTERVAL
};

inline const ConvertedType (&EnumValuesConvertedType())[23] {
  static const ConvertedType values[] = {
    ConvertedType_UNSET,
    ConvertedType_UTF8,
    ConvertedType_MAP,
    ConvertedType_MAP_KEY_VALUE,
    ConvertedType_LIST,
    ConvertedType_ENUM,
    ConvertedType_DECIMAL,
    ConvertedType_DATE,
    ConvertedType_TIME_MILLIS,
    ConvertedType_TIME_MICROS,
    ConvertedType_TIMESTAMP_MILLIS,
    ConvertedType_TIMESTAMP_MICROS,
    ConvertedType_UINT_8,
    ConvertedType_UINT_16,
    ConvertedType_UINT_32,
    ConvertedType_UINT64,
    ConvertedType_INT_8,
    ConvertedType_INT_16,
    ConvertedType_INT_32,
    ConvertedType_INT_64,
    ConvertedType_JSON,
    ConvertedType_BSON,
    ConvertedType_INTERVAL
  };
  return values;
}

inline const char * const *EnumNamesConvertedType() {
  static const char * const names[24] = {
    "UNSET",
    "UTF8",
    "MAP",
    "MAP_KEY_VALUE",
    "LIST",
    "ENUM",
    "DECIMAL",
    "DATE",
    "TIME_MILLIS",
    "TIME_MICROS",
    "TIMESTAMP_MILLIS",
    "TIMESTAMP_MICROS",
    "UINT_8",
    "UINT_16",
    "UINT_32",
    "UINT64",
    "INT_8",
    "INT_16",
    "INT_32",
    "INT_64",
    "JSON",
    "BSON",
    "INTERVAL",
    nullptr
  };
  return names;
}

inline const char *EnumNameConvertedType(ConvertedType e) {
  if (flatbuffers::IsOutRange(e, ConvertedType_UNSET, ConvertedType_INTERVAL)) return "";
  const size_t index = static_cast<size_t>(e) - static_cast<size_t>(ConvertedType_UNSET);
  return EnumNamesConvertedType()[index];
}

enum FieldRepetitionType {
  FieldRepetitionType_UNSET = -1,
  FieldRepetitionType_REQUIRED = 0,
  FieldRepetitionType_OPTIONAL = 1,
  FieldRepetitionType_REPEATED = 2,
  FieldRepetitionType_MIN = FieldRepetitionType_UNSET,
  FieldRepetitionType_MAX = FieldRepetitionType_REPEATED
};

inline const FieldRepetitionType (&EnumValuesFieldRepetitionType())[4] {
  static const FieldRepetitionType values[] = {
    FieldRepetitionType_UNSET,
    FieldRepetitionType_REQUIRED,
    FieldRepetitionType_OPTIONAL,
    FieldRepetitionType_REPEATED
  };
  return values;
}

inline const char * const *EnumNamesFieldRepetitionType() {
  static const char * const names[5] = {
    "UNSET",
    "REQUIRED",
    "OPTIONAL",
    "REPEATED",
    nullptr
  };
  return names;
}

inline const char *EnumNameFieldRepetitionType(FieldRepetitionType e) {
  if (flatbuffers::IsOutRange(e, FieldRepetitionType_UNSET, FieldRepetitionType_REPEATED)) return "";
  const size_t index = static_cast<size_t>(e) - static_cast<size_t>(FieldRepetitionType_UNSET);
  return EnumNamesFieldRepetitionType()[index];
}

enum TimeUnit {
  TimeUnit_NONE = 0,
  TimeUnit_MilliSeconds = 1,
  TimeUnit_MicroSeconds = 2,
  TimeUnit_NanoSeconds = 3,
  TimeUnit_MIN = TimeUnit_NONE,
  TimeUnit_MAX = TimeUnit_NanoSeconds
};

inline const TimeUnit (&EnumValuesTimeUnit())[4] {
  static const TimeUnit values[] = {
    TimeUnit_NONE,
    TimeUnit_MilliSeconds,
    TimeUnit_MicroSeconds,
    TimeUnit_NanoSeconds
  };
  return values;
}

inline const char * const *EnumNamesTimeUnit() {
  static const char * const names[5] = {
    "NONE",
    "MilliSeconds",
    "MicroSeconds",
    "NanoSeconds",
    nullptr
  };
  return names;
}

inline const char *EnumNameTimeUnit(TimeUnit e) {
  if (flatbuffers::IsOutRange(e, TimeUnit_NONE, TimeUnit_NanoSeconds)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesTimeUnit()[index];
}

template<typename T> struct TimeUnitTraits {
  static const TimeUnit enum_value = TimeUnit_NONE;
};

template<> struct TimeUnitTraits<parquet2::MilliSeconds> {
  static const TimeUnit enum_value = TimeUnit_MilliSeconds;
};

template<> struct TimeUnitTraits<parquet2::MicroSeconds> {
  static const TimeUnit enum_value = TimeUnit_MicroSeconds;
};

template<> struct TimeUnitTraits<parquet2::NanoSeconds> {
  static const TimeUnit enum_value = TimeUnit_NanoSeconds;
};

bool VerifyTimeUnit(flatbuffers::Verifier &verifier, const void *obj, TimeUnit type);
bool VerifyTimeUnitVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

enum LogicalType {
  LogicalType_NONE = 0,
  LogicalType_StringType = 1,
  LogicalType_MapType = 2,
  LogicalType_ListType = 3,
  LogicalType_EnumType = 4,
  LogicalType_DecimalType = 5,
  LogicalType_DateType = 6,
  LogicalType_TimeType = 7,
  LogicalType_TimestampType = 8,
  LogicalType_IntType = 9,
  LogicalType_NullType = 10,
  LogicalType_JsonType = 11,
  LogicalType_BsonType = 12,
  LogicalType_UUIDType = 13,
  LogicalType_MIN = LogicalType_NONE,
  LogicalType_MAX = LogicalType_UUIDType
};

inline const LogicalType (&EnumValuesLogicalType())[14] {
  static const LogicalType values[] = {
    LogicalType_NONE,
    LogicalType_StringType,
    LogicalType_MapType,
    LogicalType_ListType,
    LogicalType_EnumType,
    LogicalType_DecimalType,
    LogicalType_DateType,
    LogicalType_TimeType,
    LogicalType_TimestampType,
    LogicalType_IntType,
    LogicalType_NullType,
    LogicalType_JsonType,
    LogicalType_BsonType,
    LogicalType_UUIDType
  };
  return values;
}

inline const char * const *EnumNamesLogicalType() {
  static const char * const names[15] = {
    "NONE",
    "StringType",
    "MapType",
    "ListType",
    "EnumType",
    "DecimalType",
    "DateType",
    "TimeType",
    "TimestampType",
    "IntType",
    "NullType",
    "JsonType",
    "BsonType",
    "UUIDType",
    nullptr
  };
  return names;
}

inline const char *EnumNameLogicalType(LogicalType e) {
  if (flatbuffers::IsOutRange(e, LogicalType_NONE, LogicalType_UUIDType)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesLogicalType()[index];
}

template<typename T> struct LogicalTypeTraits {
  static const LogicalType enum_value = LogicalType_NONE;
};

template<> struct LogicalTypeTraits<parquet2::StringType> {
  static const LogicalType enum_value = LogicalType_StringType;
};

template<> struct LogicalTypeTraits<parquet2::MapType> {
  static const LogicalType enum_value = LogicalType_MapType;
};

template<> struct LogicalTypeTraits<parquet2::ListType> {
  static const LogicalType enum_value = LogicalType_ListType;
};

template<> struct LogicalTypeTraits<parquet2::EnumType> {
  static const LogicalType enum_value = LogicalType_EnumType;
};

template<> struct LogicalTypeTraits<parquet2::DecimalType> {
  static const LogicalType enum_value = LogicalType_DecimalType;
};

template<> struct LogicalTypeTraits<parquet2::DateType> {
  static const LogicalType enum_value = LogicalType_DateType;
};

template<> struct LogicalTypeTraits<parquet2::TimeType> {
  static const LogicalType enum_value = LogicalType_TimeType;
};

template<> struct LogicalTypeTraits<parquet2::TimestampType> {
  static const LogicalType enum_value = LogicalType_TimestampType;
};

template<> struct LogicalTypeTraits<parquet2::IntType> {
  static const LogicalType enum_value = LogicalType_IntType;
};

template<> struct LogicalTypeTraits<parquet2::NullType> {
  static const LogicalType enum_value = LogicalType_NullType;
};

template<> struct LogicalTypeTraits<parquet2::JsonType> {
  static const LogicalType enum_value = LogicalType_JsonType;
};

template<> struct LogicalTypeTraits<parquet2::BsonType> {
  static const LogicalType enum_value = LogicalType_BsonType;
};

template<> struct LogicalTypeTraits<parquet2::UUIDType> {
  static const LogicalType enum_value = LogicalType_UUIDType;
};

bool VerifyLogicalType(flatbuffers::Verifier &verifier, const void *obj, LogicalType type);
bool VerifyLogicalTypeVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

enum Encoding {
  Encoding_PLAIN = 0,
  Encoding_PLAIN_DICTIONARY = 2,
  Encoding_RLE = 3,
  Encoding_BIT_PACKED = 4,
  Encoding_DELTA_BINARY_PACKED = 5,
  Encoding_DELTA_LENGTH_BYTE_ARRAY = 6,
  Encoding_DELTA_BYTE_ARRAY = 7,
  Encoding_RLE_DICTIONARY = 8,
  Encoding_BYTE_STREAM_SPLIT = 9,
  Encoding_MIN = Encoding_PLAIN,
  Encoding_MAX = Encoding_BYTE_STREAM_SPLIT
};

inline const Encoding (&EnumValuesEncoding())[9] {
  static const Encoding values[] = {
    Encoding_PLAIN,
    Encoding_PLAIN_DICTIONARY,
    Encoding_RLE,
    Encoding_BIT_PACKED,
    Encoding_DELTA_BINARY_PACKED,
    Encoding_DELTA_LENGTH_BYTE_ARRAY,
    Encoding_DELTA_BYTE_ARRAY,
    Encoding_RLE_DICTIONARY,
    Encoding_BYTE_STREAM_SPLIT
  };
  return values;
}

inline const char * const *EnumNamesEncoding() {
  static const char * const names[11] = {
    "PLAIN",
    "",
    "PLAIN_DICTIONARY",
    "RLE",
    "BIT_PACKED",
    "DELTA_BINARY_PACKED",
    "DELTA_LENGTH_BYTE_ARRAY",
    "DELTA_BYTE_ARRAY",
    "RLE_DICTIONARY",
    "BYTE_STREAM_SPLIT",
    nullptr
  };
  return names;
}

inline const char *EnumNameEncoding(Encoding e) {
  if (flatbuffers::IsOutRange(e, Encoding_PLAIN, Encoding_BYTE_STREAM_SPLIT)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesEncoding()[index];
}

enum CompressionCodec {
  CompressionCodec_UNCOMPRESSED = 0,
  CompressionCodec_SNAPPY = 1,
  CompressionCodec_GZIP = 2,
  CompressionCodec_LZO = 3,
  CompressionCodec_BROTLI = 4,
  CompressionCodec_LZ4 = 5,
  CompressionCodec_ZSTD = 6,
  CompressionCodec_LZ4_RAW = 7,
  CompressionCodec_MIN = CompressionCodec_UNCOMPRESSED,
  CompressionCodec_MAX = CompressionCodec_LZ4_RAW
};

inline const CompressionCodec (&EnumValuesCompressionCodec())[8] {
  static const CompressionCodec values[] = {
    CompressionCodec_UNCOMPRESSED,
    CompressionCodec_SNAPPY,
    CompressionCodec_GZIP,
    CompressionCodec_LZO,
    CompressionCodec_BROTLI,
    CompressionCodec_LZ4,
    CompressionCodec_ZSTD,
    CompressionCodec_LZ4_RAW
  };
  return values;
}

inline const char * const *EnumNamesCompressionCodec() {
  static const char * const names[9] = {
    "UNCOMPRESSED",
    "SNAPPY",
    "GZIP",
    "LZO",
    "BROTLI",
    "LZ4",
    "ZSTD",
    "LZ4_RAW",
    nullptr
  };
  return names;
}

inline const char *EnumNameCompressionCodec(CompressionCodec e) {
  if (flatbuffers::IsOutRange(e, CompressionCodec_UNCOMPRESSED, CompressionCodec_LZ4_RAW)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesCompressionCodec()[index];
}

enum PageType {
  PageType_DATA_PAGE = 0,
  PageType_INDEX_PAGE = 1,
  PageType_DICTIONARY_PAGE = 2,
  PageType_DATA_PAGE_V2 = 3,
  PageType_MIN = PageType_DATA_PAGE,
  PageType_MAX = PageType_DATA_PAGE_V2
};

inline const PageType (&EnumValuesPageType())[4] {
  static const PageType values[] = {
    PageType_DATA_PAGE,
    PageType_INDEX_PAGE,
    PageType_DICTIONARY_PAGE,
    PageType_DATA_PAGE_V2
  };
  return values;
}

inline const char * const *EnumNamesPageType() {
  static const char * const names[5] = {
    "DATA_PAGE",
    "INDEX_PAGE",
    "DICTIONARY_PAGE",
    "DATA_PAGE_V2",
    nullptr
  };
  return names;
}

inline const char *EnumNamePageType(PageType e) {
  if (flatbuffers::IsOutRange(e, PageType_DATA_PAGE, PageType_DATA_PAGE_V2)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesPageType()[index];
}

enum BoundaryOrder {
  BoundaryOrder_UNORDERED = 0,
  BoundaryOrder_ASCENDING = 1,
  BoundaryOrder_DESCENDING = 2,
  BoundaryOrder_MIN = BoundaryOrder_UNORDERED,
  BoundaryOrder_MAX = BoundaryOrder_DESCENDING
};

inline const BoundaryOrder (&EnumValuesBoundaryOrder())[3] {
  static const BoundaryOrder values[] = {
    BoundaryOrder_UNORDERED,
    BoundaryOrder_ASCENDING,
    BoundaryOrder_DESCENDING
  };
  return values;
}

inline const char * const *EnumNamesBoundaryOrder() {
  static const char * const names[4] = {
    "UNORDERED",
    "ASCENDING",
    "DESCENDING",
    nullptr
  };
  return names;
}

inline const char *EnumNameBoundaryOrder(BoundaryOrder e) {
  if (flatbuffers::IsOutRange(e, BoundaryOrder_UNORDERED, BoundaryOrder_DESCENDING)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesBoundaryOrder()[index];
}

enum BloomFilterAlgorithm {
  BloomFilterAlgorithm_NONE = 0,
  BloomFilterAlgorithm_SplitBlockAlgorithm = 1,
  BloomFilterAlgorithm_MIN = BloomFilterAlgorithm_NONE,
  BloomFilterAlgorithm_MAX = BloomFilterAlgorithm_SplitBlockAlgorithm
};

inline const BloomFilterAlgorithm (&EnumValuesBloomFilterAlgorithm())[2] {
  static const BloomFilterAlgorithm values[] = {
    BloomFilterAlgorithm_NONE,
    BloomFilterAlgorithm_SplitBlockAlgorithm
  };
  return values;
}

inline const char * const *EnumNamesBloomFilterAlgorithm() {
  static const char * const names[3] = {
    "NONE",
    "SplitBlockAlgorithm",
    nullptr
  };
  return names;
}

inline const char *EnumNameBloomFilterAlgorithm(BloomFilterAlgorithm e) {
  if (flatbuffers::IsOutRange(e, BloomFilterAlgorithm_NONE, BloomFilterAlgorithm_SplitBlockAlgorithm)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesBloomFilterAlgorithm()[index];
}

template<typename T> struct BloomFilterAlgorithmTraits {
  static const BloomFilterAlgorithm enum_value = BloomFilterAlgorithm_NONE;
};

template<> struct BloomFilterAlgorithmTraits<parquet2::SplitBlockAlgorithm> {
  static const BloomFilterAlgorithm enum_value = BloomFilterAlgorithm_SplitBlockAlgorithm;
};

bool VerifyBloomFilterAlgorithm(flatbuffers::Verifier &verifier, const void *obj, BloomFilterAlgorithm type);
bool VerifyBloomFilterAlgorithmVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

enum BloomFilterHash {
  BloomFilterHash_NONE = 0,
  BloomFilterHash_XxHash = 1,
  BloomFilterHash_MIN = BloomFilterHash_NONE,
  BloomFilterHash_MAX = BloomFilterHash_XxHash
};

inline const BloomFilterHash (&EnumValuesBloomFilterHash())[2] {
  static const BloomFilterHash values[] = {
    BloomFilterHash_NONE,
    BloomFilterHash_XxHash
  };
  return values;
}

inline const char * const *EnumNamesBloomFilterHash() {
  static const char * const names[3] = {
    "NONE",
    "XxHash",
    nullptr
  };
  return names;
}

inline const char *EnumNameBloomFilterHash(BloomFilterHash e) {
  if (flatbuffers::IsOutRange(e, BloomFilterHash_NONE, BloomFilterHash_XxHash)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesBloomFilterHash()[index];
}

template<typename T> struct BloomFilterHashTraits {
  static const BloomFilterHash enum_value = BloomFilterHash_NONE;
};

template<> struct BloomFilterHashTraits<parquet2::XxHash> {
  static const BloomFilterHash enum_value = BloomFilterHash_XxHash;
};

bool VerifyBloomFilterHash(flatbuffers::Verifier &verifier, const void *obj, BloomFilterHash type);
bool VerifyBloomFilterHashVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

enum BloomFilterCompression {
  BloomFilterCompression_NONE = 0,
  BloomFilterCompression_Uncompressed = 1,
  BloomFilterCompression_MIN = BloomFilterCompression_NONE,
  BloomFilterCompression_MAX = BloomFilterCompression_Uncompressed
};

inline const BloomFilterCompression (&EnumValuesBloomFilterCompression())[2] {
  static const BloomFilterCompression values[] = {
    BloomFilterCompression_NONE,
    BloomFilterCompression_Uncompressed
  };
  return values;
}

inline const char * const *EnumNamesBloomFilterCompression() {
  static const char * const names[3] = {
    "NONE",
    "Uncompressed",
    nullptr
  };
  return names;
}

inline const char *EnumNameBloomFilterCompression(BloomFilterCompression e) {
  if (flatbuffers::IsOutRange(e, BloomFilterCompression_NONE, BloomFilterCompression_Uncompressed)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesBloomFilterCompression()[index];
}

template<typename T> struct BloomFilterCompressionTraits {
  static const BloomFilterCompression enum_value = BloomFilterCompression_NONE;
};

template<> struct BloomFilterCompressionTraits<parquet2::Uncompressed> {
  static const BloomFilterCompression enum_value = BloomFilterCompression_Uncompressed;
};

bool VerifyBloomFilterCompression(flatbuffers::Verifier &verifier, const void *obj, BloomFilterCompression type);
bool VerifyBloomFilterCompressionVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

enum ColumnCryptoMetadata {
  ColumnCryptoMetadata_NONE = 0,
  ColumnCryptoMetadata_EncryptionWithFooterKey = 1,
  ColumnCryptoMetadata_EncryptionWithColumnKey = 2,
  ColumnCryptoMetadata_MIN = ColumnCryptoMetadata_NONE,
  ColumnCryptoMetadata_MAX = ColumnCryptoMetadata_EncryptionWithColumnKey
};

inline const ColumnCryptoMetadata (&EnumValuesColumnCryptoMetadata())[3] {
  static const ColumnCryptoMetadata values[] = {
    ColumnCryptoMetadata_NONE,
    ColumnCryptoMetadata_EncryptionWithFooterKey,
    ColumnCryptoMetadata_EncryptionWithColumnKey
  };
  return values;
}

inline const char * const *EnumNamesColumnCryptoMetadata() {
  static const char * const names[4] = {
    "NONE",
    "EncryptionWithFooterKey",
    "EncryptionWithColumnKey",
    nullptr
  };
  return names;
}

inline const char *EnumNameColumnCryptoMetadata(ColumnCryptoMetadata e) {
  if (flatbuffers::IsOutRange(e, ColumnCryptoMetadata_NONE, ColumnCryptoMetadata_EncryptionWithColumnKey)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesColumnCryptoMetadata()[index];
}

template<typename T> struct ColumnCryptoMetadataTraits {
  static const ColumnCryptoMetadata enum_value = ColumnCryptoMetadata_NONE;
};

template<> struct ColumnCryptoMetadataTraits<parquet2::EncryptionWithFooterKey> {
  static const ColumnCryptoMetadata enum_value = ColumnCryptoMetadata_EncryptionWithFooterKey;
};

template<> struct ColumnCryptoMetadataTraits<parquet2::EncryptionWithColumnKey> {
  static const ColumnCryptoMetadata enum_value = ColumnCryptoMetadata_EncryptionWithColumnKey;
};

bool VerifyColumnCryptoMetadata(flatbuffers::Verifier &verifier, const void *obj, ColumnCryptoMetadata type);
bool VerifyColumnCryptoMetadataVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

enum ColumnOrder {
  ColumnOrder_NONE = 0,
  ColumnOrder_TypeDefinedOrder = 1,
  ColumnOrder_MIN = ColumnOrder_NONE,
  ColumnOrder_MAX = ColumnOrder_TypeDefinedOrder
};

inline const ColumnOrder (&EnumValuesColumnOrder())[2] {
  static const ColumnOrder values[] = {
    ColumnOrder_NONE,
    ColumnOrder_TypeDefinedOrder
  };
  return values;
}

inline const char * const *EnumNamesColumnOrder() {
  static const char * const names[3] = {
    "NONE",
    "TypeDefinedOrder",
    nullptr
  };
  return names;
}

inline const char *EnumNameColumnOrder(ColumnOrder e) {
  if (flatbuffers::IsOutRange(e, ColumnOrder_NONE, ColumnOrder_TypeDefinedOrder)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesColumnOrder()[index];
}

template<typename T> struct ColumnOrderTraits {
  static const ColumnOrder enum_value = ColumnOrder_NONE;
};

template<> struct ColumnOrderTraits<parquet2::TypeDefinedOrder> {
  static const ColumnOrder enum_value = ColumnOrder_TypeDefinedOrder;
};

bool VerifyColumnOrder(flatbuffers::Verifier &verifier, const void *obj, ColumnOrder type);
bool VerifyColumnOrderVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

enum EncryptionAlgorithm {
  EncryptionAlgorithm_NONE = 0,
  EncryptionAlgorithm_AesGcmV1 = 1,
  EncryptionAlgorithm_AesGcmCtrV1 = 2,
  EncryptionAlgorithm_MIN = EncryptionAlgorithm_NONE,
  EncryptionAlgorithm_MAX = EncryptionAlgorithm_AesGcmCtrV1
};

inline const EncryptionAlgorithm (&EnumValuesEncryptionAlgorithm())[3] {
  static const EncryptionAlgorithm values[] = {
    EncryptionAlgorithm_NONE,
    EncryptionAlgorithm_AesGcmV1,
    EncryptionAlgorithm_AesGcmCtrV1
  };
  return values;
}

inline const char * const *EnumNamesEncryptionAlgorithm() {
  static const char * const names[4] = {
    "NONE",
    "AesGcmV1",
    "AesGcmCtrV1",
    nullptr
  };
  return names;
}

inline const char *EnumNameEncryptionAlgorithm(EncryptionAlgorithm e) {
  if (flatbuffers::IsOutRange(e, EncryptionAlgorithm_NONE, EncryptionAlgorithm_AesGcmCtrV1)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesEncryptionAlgorithm()[index];
}

template<typename T> struct EncryptionAlgorithmTraits {
  static const EncryptionAlgorithm enum_value = EncryptionAlgorithm_NONE;
};

template<> struct EncryptionAlgorithmTraits<parquet2::AesGcmV1> {
  static const EncryptionAlgorithm enum_value = EncryptionAlgorithm_AesGcmV1;
};

template<> struct EncryptionAlgorithmTraits<parquet2::AesGcmCtrV1> {
  static const EncryptionAlgorithm enum_value = EncryptionAlgorithm_AesGcmCtrV1;
};

bool VerifyEncryptionAlgorithm(flatbuffers::Verifier &verifier, const void *obj, EncryptionAlgorithm type);
bool VerifyEncryptionAlgorithmVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

struct Value FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ValueBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DATA = 4
  };
  const flatbuffers::Vector<int8_t> *data() const {
    return GetPointer<const flatbuffers::Vector<int8_t> *>(VT_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           verifier.EndTable();
  }
};

struct ValueBuilder {
  typedef Value Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_data(flatbuffers::Offset<flatbuffers::Vector<int8_t>> data) {
    fbb_.AddOffset(Value::VT_DATA, data);
  }
  explicit ValueBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Value> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Value>(end);
    return o;
  }
};

inline flatbuffers::Offset<Value> CreateValue(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int8_t>> data = 0) {
  ValueBuilder builder_(_fbb);
  builder_.add_data(data);
  return builder_.Finish();
}

inline flatbuffers::Offset<Value> CreateValueDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int8_t> *data = nullptr) {
  auto data__ = data ? _fbb.CreateVector<int8_t>(*data) : 0;
  return parquet2::CreateValue(
      _fbb,
      data__);
}

struct Statistics FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef StatisticsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MAX = 4,
    VT_MIN = 6,
    VT_NULL_COUNT = 8,
    VT_DISTINCT_COUNT = 10,
    VT_MAX_VALUE = 12,
    VT_MIN_VALUE = 14,
    VT_IS_MAX_VALUE_EXACT = 16,
    VT_IS_MIN_VALUE_EXACT = 18,
    VT_MAX8 = 20,
    VT_MIN8 = 22
  };
  const flatbuffers::Vector<int8_t> *max() const {
    return GetPointer<const flatbuffers::Vector<int8_t> *>(VT_MAX);
  }
  const flatbuffers::Vector<int8_t> *min() const {
    return GetPointer<const flatbuffers::Vector<int8_t> *>(VT_MIN);
  }
  int64_t null_count() const {
    return GetField<int64_t>(VT_NULL_COUNT, 0);
  }
  int64_t distinct_count() const {
    return GetField<int64_t>(VT_DISTINCT_COUNT, 0);
  }
  const flatbuffers::Vector<int8_t> *max_value() const {
    return GetPointer<const flatbuffers::Vector<int8_t> *>(VT_MAX_VALUE);
  }
  const flatbuffers::Vector<int8_t> *min_value() const {
    return GetPointer<const flatbuffers::Vector<int8_t> *>(VT_MIN_VALUE);
  }
  bool is_max_value_exact() const {
    return GetField<uint8_t>(VT_IS_MAX_VALUE_EXACT, 0) != 0;
  }
  bool is_min_value_exact() const {
    return GetField<uint8_t>(VT_IS_MIN_VALUE_EXACT, 0) != 0;
  }
  int64_t max8() const {
    return GetField<int64_t>(VT_MAX8, 0);
  }
  int64_t min8() const {
    return GetField<int64_t>(VT_MIN8, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_MAX) &&
           verifier.VerifyVector(max()) &&
           VerifyOffset(verifier, VT_MIN) &&
           verifier.VerifyVector(min()) &&
           VerifyField<int64_t>(verifier, VT_NULL_COUNT, sizeof(int64_t)) &&
           VerifyField<int64_t>(verifier, VT_DISTINCT_COUNT, sizeof(int64_t)) &&
           VerifyOffset(verifier, VT_MAX_VALUE) &&
           verifier.VerifyVector(max_value()) &&
           VerifyOffset(verifier, VT_MIN_VALUE) &&
           verifier.VerifyVector(min_value()) &&
           VerifyField<uint8_t>(verifier, VT_IS_MAX_VALUE_EXACT, sizeof(uint8_t)) &&
           VerifyField<uint8_t>(verifier, VT_IS_MIN_VALUE_EXACT, sizeof(uint8_t)) &&
           VerifyField<int64_t>(verifier, VT_MAX8, sizeof(int64_t)) &&
           VerifyField<int64_t>(verifier, VT_MIN8, sizeof(int64_t)) &&
           verifier.EndTable();
  }
};

struct StatisticsBuilder {
  typedef Statistics Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_max(flatbuffers::Offset<flatbuffers::Vector<int8_t>> max) {
    fbb_.AddOffset(Statistics::VT_MAX, max);
  }
  void add_min(flatbuffers::Offset<flatbuffers::Vector<int8_t>> min) {
    fbb_.AddOffset(Statistics::VT_MIN, min);
  }
  void add_null_count(int64_t null_count) {
    fbb_.AddElement<int64_t>(Statistics::VT_NULL_COUNT, null_count, 0);
  }
  void add_distinct_count(int64_t distinct_count) {
    fbb_.AddElement<int64_t>(Statistics::VT_DISTINCT_COUNT, distinct_count, 0);
  }
  void add_max_value(flatbuffers::Offset<flatbuffers::Vector<int8_t>> max_value) {
    fbb_.AddOffset(Statistics::VT_MAX_VALUE, max_value);
  }
  void add_min_value(flatbuffers::Offset<flatbuffers::Vector<int8_t>> min_value) {
    fbb_.AddOffset(Statistics::VT_MIN_VALUE, min_value);
  }
  void add_is_max_value_exact(bool is_max_value_exact) {
    fbb_.AddElement<uint8_t>(Statistics::VT_IS_MAX_VALUE_EXACT, static_cast<uint8_t>(is_max_value_exact), 0);
  }
  void add_is_min_value_exact(bool is_min_value_exact) {
    fbb_.AddElement<uint8_t>(Statistics::VT_IS_MIN_VALUE_EXACT, static_cast<uint8_t>(is_min_value_exact), 0);
  }
  void add_max8(int64_t max8) {
    fbb_.AddElement<int64_t>(Statistics::VT_MAX8, max8, 0);
  }
  void add_min8(int64_t min8) {
    fbb_.AddElement<int64_t>(Statistics::VT_MIN8, min8, 0);
  }
  explicit StatisticsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Statistics> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Statistics>(end);
    return o;
  }
};

inline flatbuffers::Offset<Statistics> CreateStatistics(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int8_t>> max = 0,
    flatbuffers::Offset<flatbuffers::Vector<int8_t>> min = 0,
    int64_t null_count = 0,
    int64_t distinct_count = 0,
    flatbuffers::Offset<flatbuffers::Vector<int8_t>> max_value = 0,
    flatbuffers::Offset<flatbuffers::Vector<int8_t>> min_value = 0,
    bool is_max_value_exact = false,
    bool is_min_value_exact = false,
    int64_t max8 = 0,
    int64_t min8 = 0) {
  StatisticsBuilder builder_(_fbb);
  builder_.add_min8(min8);
  builder_.add_max8(max8);
  builder_.add_distinct_count(distinct_count);
  builder_.add_null_count(null_count);
  builder_.add_min_value(min_value);
  builder_.add_max_value(max_value);
  builder_.add_min(min);
  builder_.add_max(max);
  builder_.add_is_min_value_exact(is_min_value_exact);
  builder_.add_is_max_value_exact(is_max_value_exact);
  return builder_.Finish();
}

inline flatbuffers::Offset<Statistics> CreateStatisticsDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int8_t> *max = nullptr,
    const std::vector<int8_t> *min = nullptr,
    int64_t null_count = 0,
    int64_t distinct_count = 0,
    const std::vector<int8_t> *max_value = nullptr,
    const std::vector<int8_t> *min_value = nullptr,
    bool is_max_value_exact = false,
    bool is_min_value_exact = false,
    int64_t max8 = 0,
    int64_t min8 = 0) {
  auto max__ = max ? _fbb.CreateVector<int8_t>(*max) : 0;
  auto min__ = min ? _fbb.CreateVector<int8_t>(*min) : 0;
  auto max_value__ = max_value ? _fbb.CreateVector<int8_t>(*max_value) : 0;
  auto min_value__ = min_value ? _fbb.CreateVector<int8_t>(*min_value) : 0;
  return parquet2::CreateStatistics(
      _fbb,
      max__,
      min__,
      null_count,
      distinct_count,
      max_value__,
      min_value__,
      is_max_value_exact,
      is_min_value_exact,
      max8,
      min8);
}

struct StringType FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef StringTypeBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct StringTypeBuilder {
  typedef StringType Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit StringTypeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<StringType> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<StringType>(end);
    return o;
  }
};

inline flatbuffers::Offset<StringType> CreateStringType(
    flatbuffers::FlatBufferBuilder &_fbb) {
  StringTypeBuilder builder_(_fbb);
  return builder_.Finish();
}

struct UUIDType FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef UUIDTypeBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct UUIDTypeBuilder {
  typedef UUIDType Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit UUIDTypeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<UUIDType> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<UUIDType>(end);
    return o;
  }
};

inline flatbuffers::Offset<UUIDType> CreateUUIDType(
    flatbuffers::FlatBufferBuilder &_fbb) {
  UUIDTypeBuilder builder_(_fbb);
  return builder_.Finish();
}

struct MapType FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MapTypeBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct MapTypeBuilder {
  typedef MapType Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit MapTypeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<MapType> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MapType>(end);
    return o;
  }
};

inline flatbuffers::Offset<MapType> CreateMapType(
    flatbuffers::FlatBufferBuilder &_fbb) {
  MapTypeBuilder builder_(_fbb);
  return builder_.Finish();
}

struct ListType FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ListTypeBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct ListTypeBuilder {
  typedef ListType Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit ListTypeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ListType> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ListType>(end);
    return o;
  }
};

inline flatbuffers::Offset<ListType> CreateListType(
    flatbuffers::FlatBufferBuilder &_fbb) {
  ListTypeBuilder builder_(_fbb);
  return builder_.Finish();
}

struct EnumType FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef EnumTypeBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct EnumTypeBuilder {
  typedef EnumType Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit EnumTypeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<EnumType> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<EnumType>(end);
    return o;
  }
};

inline flatbuffers::Offset<EnumType> CreateEnumType(
    flatbuffers::FlatBufferBuilder &_fbb) {
  EnumTypeBuilder builder_(_fbb);
  return builder_.Finish();
}

struct DateType FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DateTypeBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct DateTypeBuilder {
  typedef DateType Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit DateTypeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<DateType> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DateType>(end);
    return o;
  }
};

inline flatbuffers::Offset<DateType> CreateDateType(
    flatbuffers::FlatBufferBuilder &_fbb) {
  DateTypeBuilder builder_(_fbb);
  return builder_.Finish();
}

struct NullType FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef NullTypeBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct NullTypeBuilder {
  typedef NullType Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit NullTypeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<NullType> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<NullType>(end);
    return o;
  }
};

inline flatbuffers::Offset<NullType> CreateNullType(
    flatbuffers::FlatBufferBuilder &_fbb) {
  NullTypeBuilder builder_(_fbb);
  return builder_.Finish();
}

struct DecimalType FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DecimalTypeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PRECISION = 4,
    VT_SCALE = 6
  };
  int32_t precision() const {
    return GetField<int32_t>(VT_PRECISION, 0);
  }
  int32_t scale() const {
    return GetField<int32_t>(VT_SCALE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_PRECISION, sizeof(int32_t)) &&
           VerifyField<int32_t>(verifier, VT_SCALE, sizeof(int32_t)) &&
           verifier.EndTable();
  }
};

struct DecimalTypeBuilder {
  typedef DecimalType Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_precision(int32_t precision) {
    fbb_.AddElement<int32_t>(DecimalType::VT_PRECISION, precision, 0);
  }
  void add_scale(int32_t scale) {
    fbb_.AddElement<int32_t>(DecimalType::VT_SCALE, scale, 0);
  }
  explicit DecimalTypeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<DecimalType> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DecimalType>(end);
    return o;
  }
};

inline flatbuffers::Offset<DecimalType> CreateDecimalType(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t precision = 0,
    int32_t scale = 0) {
  DecimalTypeBuilder builder_(_fbb);
  builder_.add_scale(scale);
  builder_.add_precision(precision);
  return builder_.Finish();
}

struct MilliSeconds FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MilliSecondsBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct MilliSecondsBuilder {
  typedef MilliSeconds Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit MilliSecondsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<MilliSeconds> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MilliSeconds>(end);
    return o;
  }
};

inline flatbuffers::Offset<MilliSeconds> CreateMilliSeconds(
    flatbuffers::FlatBufferBuilder &_fbb) {
  MilliSecondsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct MicroSeconds FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MicroSecondsBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct MicroSecondsBuilder {
  typedef MicroSeconds Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit MicroSecondsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<MicroSeconds> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MicroSeconds>(end);
    return o;
  }
};

inline flatbuffers::Offset<MicroSeconds> CreateMicroSeconds(
    flatbuffers::FlatBufferBuilder &_fbb) {
  MicroSecondsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct NanoSeconds FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef NanoSecondsBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct NanoSecondsBuilder {
  typedef NanoSeconds Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit NanoSecondsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<NanoSeconds> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<NanoSeconds>(end);
    return o;
  }
};

inline flatbuffers::Offset<NanoSeconds> CreateNanoSeconds(
    flatbuffers::FlatBufferBuilder &_fbb) {
  NanoSecondsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct TimestampType FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TimestampTypeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_IS_ADJUSTED_TO_UTC = 4,
    VT_UNIT_TYPE = 6,
    VT_UNIT = 8
  };
  bool is_adjusted_to_utc() const {
    return GetField<uint8_t>(VT_IS_ADJUSTED_TO_UTC, 0) != 0;
  }
  parquet2::TimeUnit unit_type() const {
    return static_cast<parquet2::TimeUnit>(GetField<uint8_t>(VT_UNIT_TYPE, 0));
  }
  const void *unit() const {
    return GetPointer<const void *>(VT_UNIT);
  }
  template<typename T> const T *unit_as() const;
  const parquet2::MilliSeconds *unit_as_MilliSeconds() const {
    return unit_type() == parquet2::TimeUnit_MilliSeconds ? static_cast<const parquet2::MilliSeconds *>(unit()) : nullptr;
  }
  const parquet2::MicroSeconds *unit_as_MicroSeconds() const {
    return unit_type() == parquet2::TimeUnit_MicroSeconds ? static_cast<const parquet2::MicroSeconds *>(unit()) : nullptr;
  }
  const parquet2::NanoSeconds *unit_as_NanoSeconds() const {
    return unit_type() == parquet2::TimeUnit_NanoSeconds ? static_cast<const parquet2::NanoSeconds *>(unit()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_IS_ADJUSTED_TO_UTC, sizeof(uint8_t)) &&
           VerifyField<uint8_t>(verifier, VT_UNIT_TYPE, sizeof(uint8_t)) &&
           VerifyOffset(verifier, VT_UNIT) &&
           VerifyTimeUnit(verifier, unit(), unit_type()) &&
           verifier.EndTable();
  }
};

template<> inline const parquet2::MilliSeconds *TimestampType::unit_as<parquet2::MilliSeconds>() const {
  return unit_as_MilliSeconds();
}

template<> inline const parquet2::MicroSeconds *TimestampType::unit_as<parquet2::MicroSeconds>() const {
  return unit_as_MicroSeconds();
}

template<> inline const parquet2::NanoSeconds *TimestampType::unit_as<parquet2::NanoSeconds>() const {
  return unit_as_NanoSeconds();
}

struct TimestampTypeBuilder {
  typedef TimestampType Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_is_adjusted_to_utc(bool is_adjusted_to_utc) {
    fbb_.AddElement<uint8_t>(TimestampType::VT_IS_ADJUSTED_TO_UTC, static_cast<uint8_t>(is_adjusted_to_utc), 0);
  }
  void add_unit_type(parquet2::TimeUnit unit_type) {
    fbb_.AddElement<uint8_t>(TimestampType::VT_UNIT_TYPE, static_cast<uint8_t>(unit_type), 0);
  }
  void add_unit(flatbuffers::Offset<void> unit) {
    fbb_.AddOffset(TimestampType::VT_UNIT, unit);
  }
  explicit TimestampTypeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<TimestampType> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TimestampType>(end);
    return o;
  }
};

inline flatbuffers::Offset<TimestampType> CreateTimestampType(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool is_adjusted_to_utc = false,
    parquet2::TimeUnit unit_type = parquet2::TimeUnit_NONE,
    flatbuffers::Offset<void> unit = 0) {
  TimestampTypeBuilder builder_(_fbb);
  builder_.add_unit(unit);
  builder_.add_unit_type(unit_type);
  builder_.add_is_adjusted_to_utc(is_adjusted_to_utc);
  return builder_.Finish();
}

struct TimeType FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TimeTypeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_IS_ADJUSTED_TO_UTC = 4,
    VT_UNIT_TYPE = 6,
    VT_UNIT = 8
  };
  bool is_adjusted_to_utc() const {
    return GetField<uint8_t>(VT_IS_ADJUSTED_TO_UTC, 0) != 0;
  }
  parquet2::TimeUnit unit_type() const {
    return static_cast<parquet2::TimeUnit>(GetField<uint8_t>(VT_UNIT_TYPE, 0));
  }
  const void *unit() const {
    return GetPointer<const void *>(VT_UNIT);
  }
  template<typename T> const T *unit_as() const;
  const parquet2::MilliSeconds *unit_as_MilliSeconds() const {
    return unit_type() == parquet2::TimeUnit_MilliSeconds ? static_cast<const parquet2::MilliSeconds *>(unit()) : nullptr;
  }
  const parquet2::MicroSeconds *unit_as_MicroSeconds() const {
    return unit_type() == parquet2::TimeUnit_MicroSeconds ? static_cast<const parquet2::MicroSeconds *>(unit()) : nullptr;
  }
  const parquet2::NanoSeconds *unit_as_NanoSeconds() const {
    return unit_type() == parquet2::TimeUnit_NanoSeconds ? static_cast<const parquet2::NanoSeconds *>(unit()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_IS_ADJUSTED_TO_UTC, sizeof(uint8_t)) &&
           VerifyField<uint8_t>(verifier, VT_UNIT_TYPE, sizeof(uint8_t)) &&
           VerifyOffset(verifier, VT_UNIT) &&
           VerifyTimeUnit(verifier, unit(), unit_type()) &&
           verifier.EndTable();
  }
};

template<> inline const parquet2::MilliSeconds *TimeType::unit_as<parquet2::MilliSeconds>() const {
  return unit_as_MilliSeconds();
}

template<> inline const parquet2::MicroSeconds *TimeType::unit_as<parquet2::MicroSeconds>() const {
  return unit_as_MicroSeconds();
}

template<> inline const parquet2::NanoSeconds *TimeType::unit_as<parquet2::NanoSeconds>() const {
  return unit_as_NanoSeconds();
}

struct TimeTypeBuilder {
  typedef TimeType Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_is_adjusted_to_utc(bool is_adjusted_to_utc) {
    fbb_.AddElement<uint8_t>(TimeType::VT_IS_ADJUSTED_TO_UTC, static_cast<uint8_t>(is_adjusted_to_utc), 0);
  }
  void add_unit_type(parquet2::TimeUnit unit_type) {
    fbb_.AddElement<uint8_t>(TimeType::VT_UNIT_TYPE, static_cast<uint8_t>(unit_type), 0);
  }
  void add_unit(flatbuffers::Offset<void> unit) {
    fbb_.AddOffset(TimeType::VT_UNIT, unit);
  }
  explicit TimeTypeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<TimeType> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TimeType>(end);
    return o;
  }
};

inline flatbuffers::Offset<TimeType> CreateTimeType(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool is_adjusted_to_utc = false,
    parquet2::TimeUnit unit_type = parquet2::TimeUnit_NONE,
    flatbuffers::Offset<void> unit = 0) {
  TimeTypeBuilder builder_(_fbb);
  builder_.add_unit(unit);
  builder_.add_unit_type(unit_type);
  builder_.add_is_adjusted_to_utc(is_adjusted_to_utc);
  return builder_.Finish();
}

struct IntType FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef IntTypeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BIT_WIDTH = 4,
    VT_IS_SIGNED = 6
  };
  int8_t bit_width() const {
    return GetField<int8_t>(VT_BIT_WIDTH, 0);
  }
  bool is_signed() const {
    return GetField<uint8_t>(VT_IS_SIGNED, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_BIT_WIDTH, sizeof(int8_t)) &&
           VerifyField<uint8_t>(verifier, VT_IS_SIGNED, sizeof(uint8_t)) &&
           verifier.EndTable();
  }
};

struct IntTypeBuilder {
  typedef IntType Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_bit_width(int8_t bit_width) {
    fbb_.AddElement<int8_t>(IntType::VT_BIT_WIDTH, bit_width, 0);
  }
  void add_is_signed(bool is_signed) {
    fbb_.AddElement<uint8_t>(IntType::VT_IS_SIGNED, static_cast<uint8_t>(is_signed), 0);
  }
  explicit IntTypeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<IntType> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<IntType>(end);
    return o;
  }
};

inline flatbuffers::Offset<IntType> CreateIntType(
    flatbuffers::FlatBufferBuilder &_fbb,
    int8_t bit_width = 0,
    bool is_signed = false) {
  IntTypeBuilder builder_(_fbb);
  builder_.add_is_signed(is_signed);
  builder_.add_bit_width(bit_width);
  return builder_.Finish();
}

struct JsonType FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef JsonTypeBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct JsonTypeBuilder {
  typedef JsonType Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit JsonTypeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<JsonType> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<JsonType>(end);
    return o;
  }
};

inline flatbuffers::Offset<JsonType> CreateJsonType(
    flatbuffers::FlatBufferBuilder &_fbb) {
  JsonTypeBuilder builder_(_fbb);
  return builder_.Finish();
}

struct BsonType FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BsonTypeBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct BsonTypeBuilder {
  typedef BsonType Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit BsonTypeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<BsonType> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BsonType>(end);
    return o;
  }
};

inline flatbuffers::Offset<BsonType> CreateBsonType(
    flatbuffers::FlatBufferBuilder &_fbb) {
  BsonTypeBuilder builder_(_fbb);
  return builder_.Finish();
}

struct SchemaElement FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SchemaElementBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYPE = 4,
    VT_TYPE_LENGTH = 6,
    VT_REPETITION_TYPE = 8,
    VT_NAME = 10,
    VT_NUM_CHILDREN = 12,
    VT_CONVERTED_TYPE = 14,
    VT_SCALE = 16,
    VT_PRECISION = 18,
    VT_FIELD_ID = 20,
    VT_LOGICAL_TYPE_TYPE = 22,
    VT_LOGICAL_TYPE = 24
  };
  parquet2::Type type() const {
    return static_cast<parquet2::Type>(GetField<int8_t>(VT_TYPE, -1));
  }
  int32_t type_length() const {
    return GetField<int32_t>(VT_TYPE_LENGTH, 0);
  }
  parquet2::FieldRepetitionType repetition_type() const {
    return static_cast<parquet2::FieldRepetitionType>(GetField<int8_t>(VT_REPETITION_TYPE, -1));
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  int32_t num_children() const {
    return GetField<int32_t>(VT_NUM_CHILDREN, 0);
  }
  parquet2::ConvertedType converted_type() const {
    return static_cast<parquet2::ConvertedType>(GetField<int8_t>(VT_CONVERTED_TYPE, -1));
  }
  int32_t scale() const {
    return GetField<int32_t>(VT_SCALE, 0);
  }
  int32_t precision() const {
    return GetField<int32_t>(VT_PRECISION, 0);
  }
  int32_t field_id() const {
    return GetField<int32_t>(VT_FIELD_ID, 0);
  }
  parquet2::LogicalType logical_type_type() const {
    return static_cast<parquet2::LogicalType>(GetField<uint8_t>(VT_LOGICAL_TYPE_TYPE, 0));
  }
  const void *logical_type() const {
    return GetPointer<const void *>(VT_LOGICAL_TYPE);
  }
  template<typename T> const T *logical_type_as() const;
  const parquet2::StringType *logical_type_as_StringType() const {
    return logical_type_type() == parquet2::LogicalType_StringType ? static_cast<const parquet2::StringType *>(logical_type()) : nullptr;
  }
  const parquet2::MapType *logical_type_as_MapType() const {
    return logical_type_type() == parquet2::LogicalType_MapType ? static_cast<const parquet2::MapType *>(logical_type()) : nullptr;
  }
  const parquet2::ListType *logical_type_as_ListType() const {
    return logical_type_type() == parquet2::LogicalType_ListType ? static_cast<const parquet2::ListType *>(logical_type()) : nullptr;
  }
  const parquet2::EnumType *logical_type_as_EnumType() const {
    return logical_type_type() == parquet2::LogicalType_EnumType ? static_cast<const parquet2::EnumType *>(logical_type()) : nullptr;
  }
  const parquet2::DecimalType *logical_type_as_DecimalType() const {
    return logical_type_type() == parquet2::LogicalType_DecimalType ? static_cast<const parquet2::DecimalType *>(logical_type()) : nullptr;
  }
  const parquet2::DateType *logical_type_as_DateType() const {
    return logical_type_type() == parquet2::LogicalType_DateType ? static_cast<const parquet2::DateType *>(logical_type()) : nullptr;
  }
  const parquet2::TimeType *logical_type_as_TimeType() const {
    return logical_type_type() == parquet2::LogicalType_TimeType ? static_cast<const parquet2::TimeType *>(logical_type()) : nullptr;
  }
  const parquet2::TimestampType *logical_type_as_TimestampType() const {
    return logical_type_type() == parquet2::LogicalType_TimestampType ? static_cast<const parquet2::TimestampType *>(logical_type()) : nullptr;
  }
  const parquet2::IntType *logical_type_as_IntType() const {
    return logical_type_type() == parquet2::LogicalType_IntType ? static_cast<const parquet2::IntType *>(logical_type()) : nullptr;
  }
  const parquet2::NullType *logical_type_as_NullType() const {
    return logical_type_type() == parquet2::LogicalType_NullType ? static_cast<const parquet2::NullType *>(logical_type()) : nullptr;
  }
  const parquet2::JsonType *logical_type_as_JsonType() const {
    return logical_type_type() == parquet2::LogicalType_JsonType ? static_cast<const parquet2::JsonType *>(logical_type()) : nullptr;
  }
  const parquet2::BsonType *logical_type_as_BsonType() const {
    return logical_type_type() == parquet2::LogicalType_BsonType ? static_cast<const parquet2::BsonType *>(logical_type()) : nullptr;
  }
  const parquet2::UUIDType *logical_type_as_UUIDType() const {
    return logical_type_type() == parquet2::LogicalType_UUIDType ? static_cast<const parquet2::UUIDType *>(logical_type()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_TYPE, sizeof(int8_t)) &&
           VerifyField<int32_t>(verifier, VT_TYPE_LENGTH, sizeof(int32_t)) &&
           VerifyField<int8_t>(verifier, VT_REPETITION_TYPE, sizeof(int8_t)) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<int32_t>(verifier, VT_NUM_CHILDREN, sizeof(int32_t)) &&
           VerifyField<int8_t>(verifier, VT_CONVERTED_TYPE, sizeof(int8_t)) &&
           VerifyField<int32_t>(verifier, VT_SCALE, sizeof(int32_t)) &&
           VerifyField<int32_t>(verifier, VT_PRECISION, sizeof(int32_t)) &&
           VerifyField<int32_t>(verifier, VT_FIELD_ID, sizeof(int32_t)) &&
           VerifyField<uint8_t>(verifier, VT_LOGICAL_TYPE_TYPE, sizeof(uint8_t)) &&
           VerifyOffset(verifier, VT_LOGICAL_TYPE) &&
           VerifyLogicalType(verifier, logical_type(), logical_type_type()) &&
           verifier.EndTable();
  }
};

template<> inline const parquet2::StringType *SchemaElement::logical_type_as<parquet2::StringType>() const {
  return logical_type_as_StringType();
}

template<> inline const parquet2::MapType *SchemaElement::logical_type_as<parquet2::MapType>() const {
  return logical_type_as_MapType();
}

template<> inline const parquet2::ListType *SchemaElement::logical_type_as<parquet2::ListType>() const {
  return logical_type_as_ListType();
}

template<> inline const parquet2::EnumType *SchemaElement::logical_type_as<parquet2::EnumType>() const {
  return logical_type_as_EnumType();
}

template<> inline const parquet2::DecimalType *SchemaElement::logical_type_as<parquet2::DecimalType>() const {
  return logical_type_as_DecimalType();
}

template<> inline const parquet2::DateType *SchemaElement::logical_type_as<parquet2::DateType>() const {
  return logical_type_as_DateType();
}

template<> inline const parquet2::TimeType *SchemaElement::logical_type_as<parquet2::TimeType>() const {
  return logical_type_as_TimeType();
}

template<> inline const parquet2::TimestampType *SchemaElement::logical_type_as<parquet2::TimestampType>() const {
  return logical_type_as_TimestampType();
}

template<> inline const parquet2::IntType *SchemaElement::logical_type_as<parquet2::IntType>() const {
  return logical_type_as_IntType();
}

template<> inline const parquet2::NullType *SchemaElement::logical_type_as<parquet2::NullType>() const {
  return logical_type_as_NullType();
}

template<> inline const parquet2::JsonType *SchemaElement::logical_type_as<parquet2::JsonType>() const {
  return logical_type_as_JsonType();
}

template<> inline const parquet2::BsonType *SchemaElement::logical_type_as<parquet2::BsonType>() const {
  return logical_type_as_BsonType();
}

template<> inline const parquet2::UUIDType *SchemaElement::logical_type_as<parquet2::UUIDType>() const {
  return logical_type_as_UUIDType();
}

struct SchemaElementBuilder {
  typedef SchemaElement Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(parquet2::Type type) {
    fbb_.AddElement<int8_t>(SchemaElement::VT_TYPE, static_cast<int8_t>(type), -1);
  }
  void add_type_length(int32_t type_length) {
    fbb_.AddElement<int32_t>(SchemaElement::VT_TYPE_LENGTH, type_length, 0);
  }
  void add_repetition_type(parquet2::FieldRepetitionType repetition_type) {
    fbb_.AddElement<int8_t>(SchemaElement::VT_REPETITION_TYPE, static_cast<int8_t>(repetition_type), -1);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(SchemaElement::VT_NAME, name);
  }
  void add_num_children(int32_t num_children) {
    fbb_.AddElement<int32_t>(SchemaElement::VT_NUM_CHILDREN, num_children, 0);
  }
  void add_converted_type(parquet2::ConvertedType converted_type) {
    fbb_.AddElement<int8_t>(SchemaElement::VT_CONVERTED_TYPE, static_cast<int8_t>(converted_type), -1);
  }
  void add_scale(int32_t scale) {
    fbb_.AddElement<int32_t>(SchemaElement::VT_SCALE, scale, 0);
  }
  void add_precision(int32_t precision) {
    fbb_.AddElement<int32_t>(SchemaElement::VT_PRECISION, precision, 0);
  }
  void add_field_id(int32_t field_id) {
    fbb_.AddElement<int32_t>(SchemaElement::VT_FIELD_ID, field_id, 0);
  }
  void add_logical_type_type(parquet2::LogicalType logical_type_type) {
    fbb_.AddElement<uint8_t>(SchemaElement::VT_LOGICAL_TYPE_TYPE, static_cast<uint8_t>(logical_type_type), 0);
  }
  void add_logical_type(flatbuffers::Offset<void> logical_type) {
    fbb_.AddOffset(SchemaElement::VT_LOGICAL_TYPE, logical_type);
  }
  explicit SchemaElementBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SchemaElement> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SchemaElement>(end);
    return o;
  }
};

inline flatbuffers::Offset<SchemaElement> CreateSchemaElement(
    flatbuffers::FlatBufferBuilder &_fbb,
    parquet2::Type type = parquet2::Type_UNSET,
    int32_t type_length = 0,
    parquet2::FieldRepetitionType repetition_type = parquet2::FieldRepetitionType_UNSET,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    int32_t num_children = 0,
    parquet2::ConvertedType converted_type = parquet2::ConvertedType_UNSET,
    int32_t scale = 0,
    int32_t precision = 0,
    int32_t field_id = 0,
    parquet2::LogicalType logical_type_type = parquet2::LogicalType_NONE,
    flatbuffers::Offset<void> logical_type = 0) {
  SchemaElementBuilder builder_(_fbb);
  builder_.add_logical_type(logical_type);
  builder_.add_field_id(field_id);
  builder_.add_precision(precision);
  builder_.add_scale(scale);
  builder_.add_num_children(num_children);
  builder_.add_name(name);
  builder_.add_type_length(type_length);
  builder_.add_logical_type_type(logical_type_type);
  builder_.add_converted_type(converted_type);
  builder_.add_repetition_type(repetition_type);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<SchemaElement> CreateSchemaElementDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    parquet2::Type type = parquet2::Type_UNSET,
    int32_t type_length = 0,
    parquet2::FieldRepetitionType repetition_type = parquet2::FieldRepetitionType_UNSET,
    const char *name = nullptr,
    int32_t num_children = 0,
    parquet2::ConvertedType converted_type = parquet2::ConvertedType_UNSET,
    int32_t scale = 0,
    int32_t precision = 0,
    int32_t field_id = 0,
    parquet2::LogicalType logical_type_type = parquet2::LogicalType_NONE,
    flatbuffers::Offset<void> logical_type = 0) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return parquet2::CreateSchemaElement(
      _fbb,
      type,
      type_length,
      repetition_type,
      name__,
      num_children,
      converted_type,
      scale,
      precision,
      field_id,
      logical_type_type,
      logical_type);
}

struct DataPageHeader FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DataPageHeaderBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NUM_VALUES = 4,
    VT_ENCODING = 6,
    VT_DEFINITION_LEVEL_ENCODING = 8,
    VT_REPETITION_LEVEL_ENCODING = 10,
    VT_STATISTICS = 12
  };
  int32_t num_values() const {
    return GetField<int32_t>(VT_NUM_VALUES, 0);
  }
  parquet2::Encoding encoding() const {
    return static_cast<parquet2::Encoding>(GetField<int8_t>(VT_ENCODING, 0));
  }
  parquet2::Encoding definition_level_encoding() const {
    return static_cast<parquet2::Encoding>(GetField<int8_t>(VT_DEFINITION_LEVEL_ENCODING, 0));
  }
  parquet2::Encoding repetition_level_encoding() const {
    return static_cast<parquet2::Encoding>(GetField<int8_t>(VT_REPETITION_LEVEL_ENCODING, 0));
  }
  const parquet2::Statistics *statistics() const {
    return GetPointer<const parquet2::Statistics *>(VT_STATISTICS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_NUM_VALUES, sizeof(int32_t)) &&
           VerifyField<int8_t>(verifier, VT_ENCODING, sizeof(int8_t)) &&
           VerifyField<int8_t>(verifier, VT_DEFINITION_LEVEL_ENCODING, sizeof(int8_t)) &&
           VerifyField<int8_t>(verifier, VT_REPETITION_LEVEL_ENCODING, sizeof(int8_t)) &&
           VerifyOffset(verifier, VT_STATISTICS) &&
           verifier.VerifyTable(statistics()) &&
           verifier.EndTable();
  }
};

struct DataPageHeaderBuilder {
  typedef DataPageHeader Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_num_values(int32_t num_values) {
    fbb_.AddElement<int32_t>(DataPageHeader::VT_NUM_VALUES, num_values, 0);
  }
  void add_encoding(parquet2::Encoding encoding) {
    fbb_.AddElement<int8_t>(DataPageHeader::VT_ENCODING, static_cast<int8_t>(encoding), 0);
  }
  void add_definition_level_encoding(parquet2::Encoding definition_level_encoding) {
    fbb_.AddElement<int8_t>(DataPageHeader::VT_DEFINITION_LEVEL_ENCODING, static_cast<int8_t>(definition_level_encoding), 0);
  }
  void add_repetition_level_encoding(parquet2::Encoding repetition_level_encoding) {
    fbb_.AddElement<int8_t>(DataPageHeader::VT_REPETITION_LEVEL_ENCODING, static_cast<int8_t>(repetition_level_encoding), 0);
  }
  void add_statistics(flatbuffers::Offset<parquet2::Statistics> statistics) {
    fbb_.AddOffset(DataPageHeader::VT_STATISTICS, statistics);
  }
  explicit DataPageHeaderBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<DataPageHeader> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DataPageHeader>(end);
    return o;
  }
};

inline flatbuffers::Offset<DataPageHeader> CreateDataPageHeader(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t num_values = 0,
    parquet2::Encoding encoding = parquet2::Encoding_PLAIN,
    parquet2::Encoding definition_level_encoding = parquet2::Encoding_PLAIN,
    parquet2::Encoding repetition_level_encoding = parquet2::Encoding_PLAIN,
    flatbuffers::Offset<parquet2::Statistics> statistics = 0) {
  DataPageHeaderBuilder builder_(_fbb);
  builder_.add_statistics(statistics);
  builder_.add_num_values(num_values);
  builder_.add_repetition_level_encoding(repetition_level_encoding);
  builder_.add_definition_level_encoding(definition_level_encoding);
  builder_.add_encoding(encoding);
  return builder_.Finish();
}

struct IndexPageHeader FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef IndexPageHeaderBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct IndexPageHeaderBuilder {
  typedef IndexPageHeader Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit IndexPageHeaderBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<IndexPageHeader> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<IndexPageHeader>(end);
    return o;
  }
};

inline flatbuffers::Offset<IndexPageHeader> CreateIndexPageHeader(
    flatbuffers::FlatBufferBuilder &_fbb) {
  IndexPageHeaderBuilder builder_(_fbb);
  return builder_.Finish();
}

struct DictionaryPageHeader FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DictionaryPageHeaderBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NUM_VALUES = 4,
    VT_ENCODING = 6,
    VT_IS_SORTED = 8
  };
  int32_t num_values() const {
    return GetField<int32_t>(VT_NUM_VALUES, 0);
  }
  parquet2::Encoding encoding() const {
    return static_cast<parquet2::Encoding>(GetField<int8_t>(VT_ENCODING, 0));
  }
  bool is_sorted() const {
    return GetField<uint8_t>(VT_IS_SORTED, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_NUM_VALUES, sizeof(int32_t)) &&
           VerifyField<int8_t>(verifier, VT_ENCODING, sizeof(int8_t)) &&
           VerifyField<uint8_t>(verifier, VT_IS_SORTED, sizeof(uint8_t)) &&
           verifier.EndTable();
  }
};

struct DictionaryPageHeaderBuilder {
  typedef DictionaryPageHeader Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_num_values(int32_t num_values) {
    fbb_.AddElement<int32_t>(DictionaryPageHeader::VT_NUM_VALUES, num_values, 0);
  }
  void add_encoding(parquet2::Encoding encoding) {
    fbb_.AddElement<int8_t>(DictionaryPageHeader::VT_ENCODING, static_cast<int8_t>(encoding), 0);
  }
  void add_is_sorted(bool is_sorted) {
    fbb_.AddElement<uint8_t>(DictionaryPageHeader::VT_IS_SORTED, static_cast<uint8_t>(is_sorted), 0);
  }
  explicit DictionaryPageHeaderBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<DictionaryPageHeader> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DictionaryPageHeader>(end);
    return o;
  }
};

inline flatbuffers::Offset<DictionaryPageHeader> CreateDictionaryPageHeader(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t num_values = 0,
    parquet2::Encoding encoding = parquet2::Encoding_PLAIN,
    bool is_sorted = false) {
  DictionaryPageHeaderBuilder builder_(_fbb);
  builder_.add_num_values(num_values);
  builder_.add_is_sorted(is_sorted);
  builder_.add_encoding(encoding);
  return builder_.Finish();
}

struct DataPageHeaderV2 FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DataPageHeaderV2Builder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NUM_VALUES = 4,
    VT_NUM_NULLS = 6,
    VT_NUM_ROWS = 8,
    VT_ENCODING = 10,
    VT_DEFINITION_LEVELS_BYTE_LENGTH = 12,
    VT_REPETITION_LEVELS_BYTE_LENGTH = 14,
    VT_IS_COMPRESSED = 16,
    VT_STATISTICS = 18
  };
  int32_t num_values() const {
    return GetField<int32_t>(VT_NUM_VALUES, 0);
  }
  int32_t num_nulls() const {
    return GetField<int32_t>(VT_NUM_NULLS, 0);
  }
  int32_t num_rows() const {
    return GetField<int32_t>(VT_NUM_ROWS, 0);
  }
  parquet2::Encoding encoding() const {
    return static_cast<parquet2::Encoding>(GetField<int8_t>(VT_ENCODING, 0));
  }
  int32_t definition_levels_byte_length() const {
    return GetField<int32_t>(VT_DEFINITION_LEVELS_BYTE_LENGTH, 0);
  }
  int32_t repetition_levels_byte_length() const {
    return GetField<int32_t>(VT_REPETITION_LEVELS_BYTE_LENGTH, 0);
  }
  bool is_compressed() const {
    return GetField<uint8_t>(VT_IS_COMPRESSED, 0) != 0;
  }
  const parquet2::Statistics *statistics() const {
    return GetPointer<const parquet2::Statistics *>(VT_STATISTICS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_NUM_VALUES, sizeof(int32_t)) &&
           VerifyField<int32_t>(verifier, VT_NUM_NULLS, sizeof(int32_t)) &&
           VerifyField<int32_t>(verifier, VT_NUM_ROWS, sizeof(int32_t)) &&
           VerifyField<int8_t>(verifier, VT_ENCODING, sizeof(int8_t)) &&
           VerifyField<int32_t>(verifier, VT_DEFINITION_LEVELS_BYTE_LENGTH, sizeof(int32_t)) &&
           VerifyField<int32_t>(verifier, VT_REPETITION_LEVELS_BYTE_LENGTH, sizeof(int32_t)) &&
           VerifyField<uint8_t>(verifier, VT_IS_COMPRESSED, sizeof(uint8_t)) &&
           VerifyOffset(verifier, VT_STATISTICS) &&
           verifier.VerifyTable(statistics()) &&
           verifier.EndTable();
  }
};

struct DataPageHeaderV2Builder {
  typedef DataPageHeaderV2 Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_num_values(int32_t num_values) {
    fbb_.AddElement<int32_t>(DataPageHeaderV2::VT_NUM_VALUES, num_values, 0);
  }
  void add_num_nulls(int32_t num_nulls) {
    fbb_.AddElement<int32_t>(DataPageHeaderV2::VT_NUM_NULLS, num_nulls, 0);
  }
  void add_num_rows(int32_t num_rows) {
    fbb_.AddElement<int32_t>(DataPageHeaderV2::VT_NUM_ROWS, num_rows, 0);
  }
  void add_encoding(parquet2::Encoding encoding) {
    fbb_.AddElement<int8_t>(DataPageHeaderV2::VT_ENCODING, static_cast<int8_t>(encoding), 0);
  }
  void add_definition_levels_byte_length(int32_t definition_levels_byte_length) {
    fbb_.AddElement<int32_t>(DataPageHeaderV2::VT_DEFINITION_LEVELS_BYTE_LENGTH, definition_levels_byte_length, 0);
  }
  void add_repetition_levels_byte_length(int32_t repetition_levels_byte_length) {
    fbb_.AddElement<int32_t>(DataPageHeaderV2::VT_REPETITION_LEVELS_BYTE_LENGTH, repetition_levels_byte_length, 0);
  }
  void add_is_compressed(bool is_compressed) {
    fbb_.AddElement<uint8_t>(DataPageHeaderV2::VT_IS_COMPRESSED, static_cast<uint8_t>(is_compressed), 0);
  }
  void add_statistics(flatbuffers::Offset<parquet2::Statistics> statistics) {
    fbb_.AddOffset(DataPageHeaderV2::VT_STATISTICS, statistics);
  }
  explicit DataPageHeaderV2Builder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<DataPageHeaderV2> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DataPageHeaderV2>(end);
    return o;
  }
};

inline flatbuffers::Offset<DataPageHeaderV2> CreateDataPageHeaderV2(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t num_values = 0,
    int32_t num_nulls = 0,
    int32_t num_rows = 0,
    parquet2::Encoding encoding = parquet2::Encoding_PLAIN,
    int32_t definition_levels_byte_length = 0,
    int32_t repetition_levels_byte_length = 0,
    bool is_compressed = false,
    flatbuffers::Offset<parquet2::Statistics> statistics = 0) {
  DataPageHeaderV2Builder builder_(_fbb);
  builder_.add_statistics(statistics);
  builder_.add_repetition_levels_byte_length(repetition_levels_byte_length);
  builder_.add_definition_levels_byte_length(definition_levels_byte_length);
  builder_.add_num_rows(num_rows);
  builder_.add_num_nulls(num_nulls);
  builder_.add_num_values(num_values);
  builder_.add_is_compressed(is_compressed);
  builder_.add_encoding(encoding);
  return builder_.Finish();
}

struct SplitBlockAlgorithm FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SplitBlockAlgorithmBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct SplitBlockAlgorithmBuilder {
  typedef SplitBlockAlgorithm Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit SplitBlockAlgorithmBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SplitBlockAlgorithm> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SplitBlockAlgorithm>(end);
    return o;
  }
};

inline flatbuffers::Offset<SplitBlockAlgorithm> CreateSplitBlockAlgorithm(
    flatbuffers::FlatBufferBuilder &_fbb) {
  SplitBlockAlgorithmBuilder builder_(_fbb);
  return builder_.Finish();
}

struct XxHash FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef XxHashBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct XxHashBuilder {
  typedef XxHash Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit XxHashBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<XxHash> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<XxHash>(end);
    return o;
  }
};

inline flatbuffers::Offset<XxHash> CreateXxHash(
    flatbuffers::FlatBufferBuilder &_fbb) {
  XxHashBuilder builder_(_fbb);
  return builder_.Finish();
}

struct Uncompressed FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef UncompressedBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct UncompressedBuilder {
  typedef Uncompressed Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit UncompressedBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Uncompressed> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Uncompressed>(end);
    return o;
  }
};

inline flatbuffers::Offset<Uncompressed> CreateUncompressed(
    flatbuffers::FlatBufferBuilder &_fbb) {
  UncompressedBuilder builder_(_fbb);
  return builder_.Finish();
}

struct BloomFilterHeader FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BloomFilterHeaderBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NUM_BYTES = 4,
    VT_ALGORITHM_TYPE = 6,
    VT_ALGORITHM = 8,
    VT_HASH_TYPE = 10,
    VT_HASH = 12,
    VT_COMPRESSION_TYPE = 14,
    VT_COMPRESSION = 16
  };
  int32_t num_bytes() const {
    return GetField<int32_t>(VT_NUM_BYTES, 0);
  }
  parquet2::BloomFilterAlgorithm algorithm_type() const {
    return static_cast<parquet2::BloomFilterAlgorithm>(GetField<uint8_t>(VT_ALGORITHM_TYPE, 0));
  }
  const void *algorithm() const {
    return GetPointer<const void *>(VT_ALGORITHM);
  }
  template<typename T> const T *algorithm_as() const;
  const parquet2::SplitBlockAlgorithm *algorithm_as_SplitBlockAlgorithm() const {
    return algorithm_type() == parquet2::BloomFilterAlgorithm_SplitBlockAlgorithm ? static_cast<const parquet2::SplitBlockAlgorithm *>(algorithm()) : nullptr;
  }
  parquet2::BloomFilterHash hash_type() const {
    return static_cast<parquet2::BloomFilterHash>(GetField<uint8_t>(VT_HASH_TYPE, 0));
  }
  const void *hash() const {
    return GetPointer<const void *>(VT_HASH);
  }
  template<typename T> const T *hash_as() const;
  const parquet2::XxHash *hash_as_XxHash() const {
    return hash_type() == parquet2::BloomFilterHash_XxHash ? static_cast<const parquet2::XxHash *>(hash()) : nullptr;
  }
  parquet2::BloomFilterCompression compression_type() const {
    return static_cast<parquet2::BloomFilterCompression>(GetField<uint8_t>(VT_COMPRESSION_TYPE, 0));
  }
  const void *compression() const {
    return GetPointer<const void *>(VT_COMPRESSION);
  }
  template<typename T> const T *compression_as() const;
  const parquet2::Uncompressed *compression_as_Uncompressed() const {
    return compression_type() == parquet2::BloomFilterCompression_Uncompressed ? static_cast<const parquet2::Uncompressed *>(compression()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_NUM_BYTES, sizeof(int32_t)) &&
           VerifyField<uint8_t>(verifier, VT_ALGORITHM_TYPE, sizeof(uint8_t)) &&
           VerifyOffset(verifier, VT_ALGORITHM) &&
           VerifyBloomFilterAlgorithm(verifier, algorithm(), algorithm_type()) &&
           VerifyField<uint8_t>(verifier, VT_HASH_TYPE, sizeof(uint8_t)) &&
           VerifyOffset(verifier, VT_HASH) &&
           VerifyBloomFilterHash(verifier, hash(), hash_type()) &&
           VerifyField<uint8_t>(verifier, VT_COMPRESSION_TYPE, sizeof(uint8_t)) &&
           VerifyOffset(verifier, VT_COMPRESSION) &&
           VerifyBloomFilterCompression(verifier, compression(), compression_type()) &&
           verifier.EndTable();
  }
};

template<> inline const parquet2::SplitBlockAlgorithm *BloomFilterHeader::algorithm_as<parquet2::SplitBlockAlgorithm>() const {
  return algorithm_as_SplitBlockAlgorithm();
}

template<> inline const parquet2::XxHash *BloomFilterHeader::hash_as<parquet2::XxHash>() const {
  return hash_as_XxHash();
}

template<> inline const parquet2::Uncompressed *BloomFilterHeader::compression_as<parquet2::Uncompressed>() const {
  return compression_as_Uncompressed();
}

struct BloomFilterHeaderBuilder {
  typedef BloomFilterHeader Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_num_bytes(int32_t num_bytes) {
    fbb_.AddElement<int32_t>(BloomFilterHeader::VT_NUM_BYTES, num_bytes, 0);
  }
  void add_algorithm_type(parquet2::BloomFilterAlgorithm algorithm_type) {
    fbb_.AddElement<uint8_t>(BloomFilterHeader::VT_ALGORITHM_TYPE, static_cast<uint8_t>(algorithm_type), 0);
  }
  void add_algorithm(flatbuffers::Offset<void> algorithm) {
    fbb_.AddOffset(BloomFilterHeader::VT_ALGORITHM, algorithm);
  }
  void add_hash_type(parquet2::BloomFilterHash hash_type) {
    fbb_.AddElement<uint8_t>(BloomFilterHeader::VT_HASH_TYPE, static_cast<uint8_t>(hash_type), 0);
  }
  void add_hash(flatbuffers::Offset<void> hash) {
    fbb_.AddOffset(BloomFilterHeader::VT_HASH, hash);
  }
  void add_compression_type(parquet2::BloomFilterCompression compression_type) {
    fbb_.AddElement<uint8_t>(BloomFilterHeader::VT_COMPRESSION_TYPE, static_cast<uint8_t>(compression_type), 0);
  }
  void add_compression(flatbuffers::Offset<void> compression) {
    fbb_.AddOffset(BloomFilterHeader::VT_COMPRESSION, compression);
  }
  explicit BloomFilterHeaderBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<BloomFilterHeader> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BloomFilterHeader>(end);
    return o;
  }
};

inline flatbuffers::Offset<BloomFilterHeader> CreateBloomFilterHeader(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t num_bytes = 0,
    parquet2::BloomFilterAlgorithm algorithm_type = parquet2::BloomFilterAlgorithm_NONE,
    flatbuffers::Offset<void> algorithm = 0,
    parquet2::BloomFilterHash hash_type = parquet2::BloomFilterHash_NONE,
    flatbuffers::Offset<void> hash = 0,
    parquet2::BloomFilterCompression compression_type = parquet2::BloomFilterCompression_NONE,
    flatbuffers::Offset<void> compression = 0) {
  BloomFilterHeaderBuilder builder_(_fbb);
  builder_.add_compression(compression);
  builder_.add_hash(hash);
  builder_.add_algorithm(algorithm);
  builder_.add_num_bytes(num_bytes);
  builder_.add_compression_type(compression_type);
  builder_.add_hash_type(hash_type);
  builder_.add_algorithm_type(algorithm_type);
  return builder_.Finish();
}

struct PageHeader FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PageHeaderBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYPE = 4,
    VT_UNCOMPRESSED_PAGE_SIZE = 6,
    VT_COMPRESSED_PAGE_SIZE = 8,
    VT_CRC = 10,
    VT_DATA_PAGE_HEADER = 12,
    VT_INDEX_PAGE_HEADER = 14,
    VT_DICTIONARY_PAGE_HEADER = 16,
    VT_DATA_PAGE_HEADER_V2 = 18
  };
  parquet2::PageType type() const {
    return static_cast<parquet2::PageType>(GetField<int8_t>(VT_TYPE, 0));
  }
  int32_t uncompressed_page_size() const {
    return GetField<int32_t>(VT_UNCOMPRESSED_PAGE_SIZE, 0);
  }
  int32_t compressed_page_size() const {
    return GetField<int32_t>(VT_COMPRESSED_PAGE_SIZE, 0);
  }
  int32_t crc() const {
    return GetField<int32_t>(VT_CRC, 0);
  }
  const parquet2::DataPageHeader *data_page_header() const {
    return GetPointer<const parquet2::DataPageHeader *>(VT_DATA_PAGE_HEADER);
  }
  const parquet2::IndexPageHeader *index_page_header() const {
    return GetPointer<const parquet2::IndexPageHeader *>(VT_INDEX_PAGE_HEADER);
  }
  const parquet2::DictionaryPageHeader *dictionary_page_header() const {
    return GetPointer<const parquet2::DictionaryPageHeader *>(VT_DICTIONARY_PAGE_HEADER);
  }
  const parquet2::DataPageHeaderV2 *data_page_header_v2() const {
    return GetPointer<const parquet2::DataPageHeaderV2 *>(VT_DATA_PAGE_HEADER_V2);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_TYPE, sizeof(int8_t)) &&
           VerifyField<int32_t>(verifier, VT_UNCOMPRESSED_PAGE_SIZE, sizeof(int32_t)) &&
           VerifyField<int32_t>(verifier, VT_COMPRESSED_PAGE_SIZE, sizeof(int32_t)) &&
           VerifyField<int32_t>(verifier, VT_CRC, sizeof(int32_t)) &&
           VerifyOffset(verifier, VT_DATA_PAGE_HEADER) &&
           verifier.VerifyTable(data_page_header()) &&
           VerifyOffset(verifier, VT_INDEX_PAGE_HEADER) &&
           verifier.VerifyTable(index_page_header()) &&
           VerifyOffset(verifier, VT_DICTIONARY_PAGE_HEADER) &&
           verifier.VerifyTable(dictionary_page_header()) &&
           VerifyOffset(verifier, VT_DATA_PAGE_HEADER_V2) &&
           verifier.VerifyTable(data_page_header_v2()) &&
           verifier.EndTable();
  }
};

struct PageHeaderBuilder {
  typedef PageHeader Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(parquet2::PageType type) {
    fbb_.AddElement<int8_t>(PageHeader::VT_TYPE, static_cast<int8_t>(type), 0);
  }
  void add_uncompressed_page_size(int32_t uncompressed_page_size) {
    fbb_.AddElement<int32_t>(PageHeader::VT_UNCOMPRESSED_PAGE_SIZE, uncompressed_page_size, 0);
  }
  void add_compressed_page_size(int32_t compressed_page_size) {
    fbb_.AddElement<int32_t>(PageHeader::VT_COMPRESSED_PAGE_SIZE, compressed_page_size, 0);
  }
  void add_crc(int32_t crc) {
    fbb_.AddElement<int32_t>(PageHeader::VT_CRC, crc, 0);
  }
  void add_data_page_header(flatbuffers::Offset<parquet2::DataPageHeader> data_page_header) {
    fbb_.AddOffset(PageHeader::VT_DATA_PAGE_HEADER, data_page_header);
  }
  void add_index_page_header(flatbuffers::Offset<parquet2::IndexPageHeader> index_page_header) {
    fbb_.AddOffset(PageHeader::VT_INDEX_PAGE_HEADER, index_page_header);
  }
  void add_dictionary_page_header(flatbuffers::Offset<parquet2::DictionaryPageHeader> dictionary_page_header) {
    fbb_.AddOffset(PageHeader::VT_DICTIONARY_PAGE_HEADER, dictionary_page_header);
  }
  void add_data_page_header_v2(flatbuffers::Offset<parquet2::DataPageHeaderV2> data_page_header_v2) {
    fbb_.AddOffset(PageHeader::VT_DATA_PAGE_HEADER_V2, data_page_header_v2);
  }
  explicit PageHeaderBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<PageHeader> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PageHeader>(end);
    return o;
  }
};

inline flatbuffers::Offset<PageHeader> CreatePageHeader(
    flatbuffers::FlatBufferBuilder &_fbb,
    parquet2::PageType type = parquet2::PageType_DATA_PAGE,
    int32_t uncompressed_page_size = 0,
    int32_t compressed_page_size = 0,
    int32_t crc = 0,
    flatbuffers::Offset<parquet2::DataPageHeader> data_page_header = 0,
    flatbuffers::Offset<parquet2::IndexPageHeader> index_page_header = 0,
    flatbuffers::Offset<parquet2::DictionaryPageHeader> dictionary_page_header = 0,
    flatbuffers::Offset<parquet2::DataPageHeaderV2> data_page_header_v2 = 0) {
  PageHeaderBuilder builder_(_fbb);
  builder_.add_data_page_header_v2(data_page_header_v2);
  builder_.add_dictionary_page_header(dictionary_page_header);
  builder_.add_index_page_header(index_page_header);
  builder_.add_data_page_header(data_page_header);
  builder_.add_crc(crc);
  builder_.add_compressed_page_size(compressed_page_size);
  builder_.add_uncompressed_page_size(uncompressed_page_size);
  builder_.add_type(type);
  return builder_.Finish();
}

struct KeyValue FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef KeyValueBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_KEY = 4,
    VT_VALUE = 6
  };
  const flatbuffers::String *key() const {
    return GetPointer<const flatbuffers::String *>(VT_KEY);
  }
  const flatbuffers::String *value() const {
    return GetPointer<const flatbuffers::String *>(VT_VALUE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_KEY) &&
           verifier.VerifyString(key()) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.VerifyString(value()) &&
           verifier.EndTable();
  }
};

struct KeyValueBuilder {
  typedef KeyValue Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_key(flatbuffers::Offset<flatbuffers::String> key) {
    fbb_.AddOffset(KeyValue::VT_KEY, key);
  }
  void add_value(flatbuffers::Offset<flatbuffers::String> value) {
    fbb_.AddOffset(KeyValue::VT_VALUE, value);
  }
  explicit KeyValueBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<KeyValue> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<KeyValue>(end);
    return o;
  }
};

inline flatbuffers::Offset<KeyValue> CreateKeyValue(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> key = 0,
    flatbuffers::Offset<flatbuffers::String> value = 0) {
  KeyValueBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_key(key);
  return builder_.Finish();
}

inline flatbuffers::Offset<KeyValue> CreateKeyValueDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *key = nullptr,
    const char *value = nullptr) {
  auto key__ = key ? _fbb.CreateString(key) : 0;
  auto value__ = value ? _fbb.CreateString(value) : 0;
  return parquet2::CreateKeyValue(
      _fbb,
      key__,
      value__);
}

struct SortingColumn FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SortingColumnBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_COLUMN_IDX = 4,
    VT_DESCENDING = 6,
    VT_NULLS_FIRST = 8
  };
  int32_t column_idx() const {
    return GetField<int32_t>(VT_COLUMN_IDX, 0);
  }
  bool descending() const {
    return GetField<uint8_t>(VT_DESCENDING, 0) != 0;
  }
  bool nulls_first() const {
    return GetField<uint8_t>(VT_NULLS_FIRST, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_COLUMN_IDX, sizeof(int32_t)) &&
           VerifyField<uint8_t>(verifier, VT_DESCENDING, sizeof(uint8_t)) &&
           VerifyField<uint8_t>(verifier, VT_NULLS_FIRST, sizeof(uint8_t)) &&
           verifier.EndTable();
  }
};

struct SortingColumnBuilder {
  typedef SortingColumn Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_column_idx(int32_t column_idx) {
    fbb_.AddElement<int32_t>(SortingColumn::VT_COLUMN_IDX, column_idx, 0);
  }
  void add_descending(bool descending) {
    fbb_.AddElement<uint8_t>(SortingColumn::VT_DESCENDING, static_cast<uint8_t>(descending), 0);
  }
  void add_nulls_first(bool nulls_first) {
    fbb_.AddElement<uint8_t>(SortingColumn::VT_NULLS_FIRST, static_cast<uint8_t>(nulls_first), 0);
  }
  explicit SortingColumnBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SortingColumn> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SortingColumn>(end);
    return o;
  }
};

inline flatbuffers::Offset<SortingColumn> CreateSortingColumn(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t column_idx = 0,
    bool descending = false,
    bool nulls_first = false) {
  SortingColumnBuilder builder_(_fbb);
  builder_.add_column_idx(column_idx);
  builder_.add_nulls_first(nulls_first);
  builder_.add_descending(descending);
  return builder_.Finish();
}

struct PageEncodingStats FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PageEncodingStatsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PAGE_TYPE = 4,
    VT_ENCODING = 6,
    VT_COUNT = 8
  };
  parquet2::PageType page_type() const {
    return static_cast<parquet2::PageType>(GetField<int8_t>(VT_PAGE_TYPE, 0));
  }
  parquet2::Encoding encoding() const {
    return static_cast<parquet2::Encoding>(GetField<int8_t>(VT_ENCODING, 0));
  }
  int32_t count() const {
    return GetField<int32_t>(VT_COUNT, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_PAGE_TYPE, sizeof(int8_t)) &&
           VerifyField<int8_t>(verifier, VT_ENCODING, sizeof(int8_t)) &&
           VerifyField<int32_t>(verifier, VT_COUNT, sizeof(int32_t)) &&
           verifier.EndTable();
  }
};

struct PageEncodingStatsBuilder {
  typedef PageEncodingStats Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_page_type(parquet2::PageType page_type) {
    fbb_.AddElement<int8_t>(PageEncodingStats::VT_PAGE_TYPE, static_cast<int8_t>(page_type), 0);
  }
  void add_encoding(parquet2::Encoding encoding) {
    fbb_.AddElement<int8_t>(PageEncodingStats::VT_ENCODING, static_cast<int8_t>(encoding), 0);
  }
  void add_count(int32_t count) {
    fbb_.AddElement<int32_t>(PageEncodingStats::VT_COUNT, count, 0);
  }
  explicit PageEncodingStatsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<PageEncodingStats> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PageEncodingStats>(end);
    return o;
  }
};

inline flatbuffers::Offset<PageEncodingStats> CreatePageEncodingStats(
    flatbuffers::FlatBufferBuilder &_fbb,
    parquet2::PageType page_type = parquet2::PageType_DATA_PAGE,
    parquet2::Encoding encoding = parquet2::Encoding_PLAIN,
    int32_t count = 0) {
  PageEncodingStatsBuilder builder_(_fbb);
  builder_.add_count(count);
  builder_.add_encoding(encoding);
  builder_.add_page_type(page_type);
  return builder_.Finish();
}

struct ColumnMetadata FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ColumnMetadataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYPE = 4,
    VT_ENCODINGS = 6,
    VT_PATH_IN_SCHEMA = 8,
    VT_CODEC = 10,
    VT_NUM_VALUES = 12,
    VT_TOTAL_UNCOMPRESSED_SIZE = 14,
    VT_TOTAL_COMPRESSED_SIZE = 16,
    VT_KEY_VALUE_METADATA = 18,
    VT_DATA_PAGE_OFFSET = 20,
    VT_INDEX_PAGE_OFFSET = 22,
    VT_DICTIONARY_PAGE_OFFSET = 24,
    VT_STATISTICS = 26,
    VT_ENCODING_STATS = 28,
    VT_BLOOM_FILTER_OFFSET = 30,
    VT_SCHEMA_INDEX = 32
  };
  parquet2::Type type() const {
    return static_cast<parquet2::Type>(GetField<int8_t>(VT_TYPE, 0));
  }
  const flatbuffers::Vector<int8_t> *encodings() const {
    return GetPointer<const flatbuffers::Vector<int8_t> *>(VT_ENCODINGS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *path_in_schema() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_PATH_IN_SCHEMA);
  }
  parquet2::CompressionCodec codec() const {
    return static_cast<parquet2::CompressionCodec>(GetField<int8_t>(VT_CODEC, 0));
  }
  int64_t num_values() const {
    return GetField<int64_t>(VT_NUM_VALUES, 0);
  }
  int64_t total_uncompressed_size() const {
    return GetField<int64_t>(VT_TOTAL_UNCOMPRESSED_SIZE, 0);
  }
  int64_t total_compressed_size() const {
    return GetField<int64_t>(VT_TOTAL_COMPRESSED_SIZE, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<parquet2::KeyValue>> *key_value_metadata() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<parquet2::KeyValue>> *>(VT_KEY_VALUE_METADATA);
  }
  int64_t data_page_offset() const {
    return GetField<int64_t>(VT_DATA_PAGE_OFFSET, 0);
  }
  int64_t index_page_offset() const {
    return GetField<int64_t>(VT_INDEX_PAGE_OFFSET, -1LL);
  }
  int64_t dictionary_page_offset() const {
    return GetField<int64_t>(VT_DICTIONARY_PAGE_OFFSET, -1LL);
  }
  const parquet2::Statistics *statistics() const {
    return GetPointer<const parquet2::Statistics *>(VT_STATISTICS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<parquet2::PageEncodingStats>> *encoding_stats() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<parquet2::PageEncodingStats>> *>(VT_ENCODING_STATS);
  }
  int64_t bloom_filter_offset() const {
    return GetField<int64_t>(VT_BLOOM_FILTER_OFFSET, -1LL);
  }
  int32_t schema_index() const {
    return GetField<int32_t>(VT_SCHEMA_INDEX, -1);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_TYPE, sizeof(int8_t)) &&
           VerifyOffset(verifier, VT_ENCODINGS) &&
           verifier.VerifyVector(encodings()) &&
           VerifyOffset(verifier, VT_PATH_IN_SCHEMA) &&
           verifier.VerifyVector(path_in_schema()) &&
           verifier.VerifyVectorOfStrings(path_in_schema()) &&
           VerifyField<int8_t>(verifier, VT_CODEC, sizeof(int8_t)) &&
           VerifyField<int64_t>(verifier, VT_NUM_VALUES, sizeof(int64_t)) &&
           VerifyField<int64_t>(verifier, VT_TOTAL_UNCOMPRESSED_SIZE, sizeof(int64_t)) &&
           VerifyField<int64_t>(verifier, VT_TOTAL_COMPRESSED_SIZE, sizeof(int64_t)) &&
           VerifyOffset(verifier, VT_KEY_VALUE_METADATA) &&
           verifier.VerifyVector(key_value_metadata()) &&
           verifier.VerifyVectorOfTables(key_value_metadata()) &&
           VerifyField<int64_t>(verifier, VT_DATA_PAGE_OFFSET, sizeof(int64_t)) &&
           VerifyField<int64_t>(verifier, VT_INDEX_PAGE_OFFSET, sizeof(int64_t)) &&
           VerifyField<int64_t>(verifier, VT_DICTIONARY_PAGE_OFFSET, sizeof(int64_t)) &&
           VerifyOffset(verifier, VT_STATISTICS) &&
           verifier.VerifyTable(statistics()) &&
           VerifyOffset(verifier, VT_ENCODING_STATS) &&
           verifier.VerifyVector(encoding_stats()) &&
           verifier.VerifyVectorOfTables(encoding_stats()) &&
           VerifyField<int64_t>(verifier, VT_BLOOM_FILTER_OFFSET, sizeof(int64_t)) &&
           VerifyField<int32_t>(verifier, VT_SCHEMA_INDEX, sizeof(int32_t)) &&
           verifier.EndTable();
  }
};

struct ColumnMetadataBuilder {
  typedef ColumnMetadata Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(parquet2::Type type) {
    fbb_.AddElement<int8_t>(ColumnMetadata::VT_TYPE, static_cast<int8_t>(type), 0);
  }
  void add_encodings(flatbuffers::Offset<flatbuffers::Vector<int8_t>> encodings) {
    fbb_.AddOffset(ColumnMetadata::VT_ENCODINGS, encodings);
  }
  void add_path_in_schema(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> path_in_schema) {
    fbb_.AddOffset(ColumnMetadata::VT_PATH_IN_SCHEMA, path_in_schema);
  }
  void add_codec(parquet2::CompressionCodec codec) {
    fbb_.AddElement<int8_t>(ColumnMetadata::VT_CODEC, static_cast<int8_t>(codec), 0);
  }
  void add_num_values(int64_t num_values) {
    fbb_.AddElement<int64_t>(ColumnMetadata::VT_NUM_VALUES, num_values, 0);
  }
  void add_total_uncompressed_size(int64_t total_uncompressed_size) {
    fbb_.AddElement<int64_t>(ColumnMetadata::VT_TOTAL_UNCOMPRESSED_SIZE, total_uncompressed_size, 0);
  }
  void add_total_compressed_size(int64_t total_compressed_size) {
    fbb_.AddElement<int64_t>(ColumnMetadata::VT_TOTAL_COMPRESSED_SIZE, total_compressed_size, 0);
  }
  void add_key_value_metadata(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<parquet2::KeyValue>>> key_value_metadata) {
    fbb_.AddOffset(ColumnMetadata::VT_KEY_VALUE_METADATA, key_value_metadata);
  }
  void add_data_page_offset(int64_t data_page_offset) {
    fbb_.AddElement<int64_t>(ColumnMetadata::VT_DATA_PAGE_OFFSET, data_page_offset, 0);
  }
  void add_index_page_offset(int64_t index_page_offset) {
    fbb_.AddElement<int64_t>(ColumnMetadata::VT_INDEX_PAGE_OFFSET, index_page_offset, -1LL);
  }
  void add_dictionary_page_offset(int64_t dictionary_page_offset) {
    fbb_.AddElement<int64_t>(ColumnMetadata::VT_DICTIONARY_PAGE_OFFSET, dictionary_page_offset, -1LL);
  }
  void add_statistics(flatbuffers::Offset<parquet2::Statistics> statistics) {
    fbb_.AddOffset(ColumnMetadata::VT_STATISTICS, statistics);
  }
  void add_encoding_stats(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<parquet2::PageEncodingStats>>> encoding_stats) {
    fbb_.AddOffset(ColumnMetadata::VT_ENCODING_STATS, encoding_stats);
  }
  void add_bloom_filter_offset(int64_t bloom_filter_offset) {
    fbb_.AddElement<int64_t>(ColumnMetadata::VT_BLOOM_FILTER_OFFSET, bloom_filter_offset, -1LL);
  }
  void add_schema_index(int32_t schema_index) {
    fbb_.AddElement<int32_t>(ColumnMetadata::VT_SCHEMA_INDEX, schema_index, -1);
  }
  explicit ColumnMetadataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ColumnMetadata> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ColumnMetadata>(end);
    return o;
  }
};

inline flatbuffers::Offset<ColumnMetadata> CreateColumnMetadata(
    flatbuffers::FlatBufferBuilder &_fbb,
    parquet2::Type type = parquet2::Type_BOOLEAN,
    flatbuffers::Offset<flatbuffers::Vector<int8_t>> encodings = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> path_in_schema = 0,
    parquet2::CompressionCodec codec = parquet2::CompressionCodec_UNCOMPRESSED,
    int64_t num_values = 0,
    int64_t total_uncompressed_size = 0,
    int64_t total_compressed_size = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<parquet2::KeyValue>>> key_value_metadata = 0,
    int64_t data_page_offset = 0,
    int64_t index_page_offset = -1LL,
    int64_t dictionary_page_offset = -1LL,
    flatbuffers::Offset<parquet2::Statistics> statistics = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<parquet2::PageEncodingStats>>> encoding_stats = 0,
    int64_t bloom_filter_offset = -1LL,
    int32_t schema_index = -1) {
  ColumnMetadataBuilder builder_(_fbb);
  builder_.add_bloom_filter_offset(bloom_filter_offset);
  builder_.add_dictionary_page_offset(dictionary_page_offset);
  builder_.add_index_page_offset(index_page_offset);
  builder_.add_data_page_offset(data_page_offset);
  builder_.add_total_compressed_size(total_compressed_size);
  builder_.add_total_uncompressed_size(total_uncompressed_size);
  builder_.add_num_values(num_values);
  builder_.add_schema_index(schema_index);
  builder_.add_encoding_stats(encoding_stats);
  builder_.add_statistics(statistics);
  builder_.add_key_value_metadata(key_value_metadata);
  builder_.add_path_in_schema(path_in_schema);
  builder_.add_encodings(encodings);
  builder_.add_codec(codec);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<ColumnMetadata> CreateColumnMetadataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    parquet2::Type type = parquet2::Type_BOOLEAN,
    const std::vector<int8_t> *encodings = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *path_in_schema = nullptr,
    parquet2::CompressionCodec codec = parquet2::CompressionCodec_UNCOMPRESSED,
    int64_t num_values = 0,
    int64_t total_uncompressed_size = 0,
    int64_t total_compressed_size = 0,
    const std::vector<flatbuffers::Offset<parquet2::KeyValue>> *key_value_metadata = nullptr,
    int64_t data_page_offset = 0,
    int64_t index_page_offset = -1LL,
    int64_t dictionary_page_offset = -1LL,
    flatbuffers::Offset<parquet2::Statistics> statistics = 0,
    const std::vector<flatbuffers::Offset<parquet2::PageEncodingStats>> *encoding_stats = nullptr,
    int64_t bloom_filter_offset = -1LL,
    int32_t schema_index = -1) {
  auto encodings__ = encodings ? _fbb.CreateVector<int8_t>(*encodings) : 0;
  auto path_in_schema__ = path_in_schema ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*path_in_schema) : 0;
  auto key_value_metadata__ = key_value_metadata ? _fbb.CreateVector<flatbuffers::Offset<parquet2::KeyValue>>(*key_value_metadata) : 0;
  auto encoding_stats__ = encoding_stats ? _fbb.CreateVector<flatbuffers::Offset<parquet2::PageEncodingStats>>(*encoding_stats) : 0;
  return parquet2::CreateColumnMetadata(
      _fbb,
      type,
      encodings__,
      path_in_schema__,
      codec,
      num_values,
      total_uncompressed_size,
      total_compressed_size,
      key_value_metadata__,
      data_page_offset,
      index_page_offset,
      dictionary_page_offset,
      statistics,
      encoding_stats__,
      bloom_filter_offset,
      schema_index);
}

struct EncryptionWithFooterKey FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef EncryptionWithFooterKeyBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct EncryptionWithFooterKeyBuilder {
  typedef EncryptionWithFooterKey Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit EncryptionWithFooterKeyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<EncryptionWithFooterKey> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<EncryptionWithFooterKey>(end);
    return o;
  }
};

inline flatbuffers::Offset<EncryptionWithFooterKey> CreateEncryptionWithFooterKey(
    flatbuffers::FlatBufferBuilder &_fbb) {
  EncryptionWithFooterKeyBuilder builder_(_fbb);
  return builder_.Finish();
}

struct EncryptionWithColumnKey FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef EncryptionWithColumnKeyBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PATH_IN_SCHEMA = 4,
    VT_KEY_METADATA = 6
  };
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *path_in_schema() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_PATH_IN_SCHEMA);
  }
  const flatbuffers::Vector<int8_t> *key_metadata() const {
    return GetPointer<const flatbuffers::Vector<int8_t> *>(VT_KEY_METADATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PATH_IN_SCHEMA) &&
           verifier.VerifyVector(path_in_schema()) &&
           verifier.VerifyVectorOfStrings(path_in_schema()) &&
           VerifyOffset(verifier, VT_KEY_METADATA) &&
           verifier.VerifyVector(key_metadata()) &&
           verifier.EndTable();
  }
};

struct EncryptionWithColumnKeyBuilder {
  typedef EncryptionWithColumnKey Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_path_in_schema(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> path_in_schema) {
    fbb_.AddOffset(EncryptionWithColumnKey::VT_PATH_IN_SCHEMA, path_in_schema);
  }
  void add_key_metadata(flatbuffers::Offset<flatbuffers::Vector<int8_t>> key_metadata) {
    fbb_.AddOffset(EncryptionWithColumnKey::VT_KEY_METADATA, key_metadata);
  }
  explicit EncryptionWithColumnKeyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<EncryptionWithColumnKey> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<EncryptionWithColumnKey>(end);
    return o;
  }
};

inline flatbuffers::Offset<EncryptionWithColumnKey> CreateEncryptionWithColumnKey(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> path_in_schema = 0,
    flatbuffers::Offset<flatbuffers::Vector<int8_t>> key_metadata = 0) {
  EncryptionWithColumnKeyBuilder builder_(_fbb);
  builder_.add_key_metadata(key_metadata);
  builder_.add_path_in_schema(path_in_schema);
  return builder_.Finish();
}

inline flatbuffers::Offset<EncryptionWithColumnKey> CreateEncryptionWithColumnKeyDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *path_in_schema = nullptr,
    const std::vector<int8_t> *key_metadata = nullptr) {
  auto path_in_schema__ = path_in_schema ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*path_in_schema) : 0;
  auto key_metadata__ = key_metadata ? _fbb.CreateVector<int8_t>(*key_metadata) : 0;
  return parquet2::CreateEncryptionWithColumnKey(
      _fbb,
      path_in_schema__,
      key_metadata__);
}

struct ColumnChunk FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ColumnChunkBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FILE_PATH = 4,
    VT_FILE_OFFSET = 6,
    VT_META_DATA = 8,
    VT_OFFSET_INDEX_OFFSET = 10,
    VT_OFFSET_INDEX_LENGTH = 12,
    VT_COLUMN_INDEX_OFFSET = 14,
    VT_COLUMN_INDEX_LENGTH = 16,
    VT_CRYPTO_METADATA_TYPE = 18,
    VT_CRYPTO_METADATA = 20,
    VT_ENCRYPTED_COLUMN_METADATA = 22
  };
  const flatbuffers::String *file_path() const {
    return GetPointer<const flatbuffers::String *>(VT_FILE_PATH);
  }
  int64_t file_offset() const {
    return GetField<int64_t>(VT_FILE_OFFSET, 0);
  }
  const parquet2::ColumnMetadata *meta_data() const {
    return GetPointer<const parquet2::ColumnMetadata *>(VT_META_DATA);
  }
  int64_t offset_index_offset() const {
    return GetField<int64_t>(VT_OFFSET_INDEX_OFFSET, -1LL);
  }
  int32_t offset_index_length() const {
    return GetField<int32_t>(VT_OFFSET_INDEX_LENGTH, -1);
  }
  int64_t column_index_offset() const {
    return GetField<int64_t>(VT_COLUMN_INDEX_OFFSET, -1LL);
  }
  int32_t column_index_length() const {
    return GetField<int32_t>(VT_COLUMN_INDEX_LENGTH, -1);
  }
  parquet2::ColumnCryptoMetadata crypto_metadata_type() const {
    return static_cast<parquet2::ColumnCryptoMetadata>(GetField<uint8_t>(VT_CRYPTO_METADATA_TYPE, 0));
  }
  const void *crypto_metadata() const {
    return GetPointer<const void *>(VT_CRYPTO_METADATA);
  }
  template<typename T> const T *crypto_metadata_as() const;
  const parquet2::EncryptionWithFooterKey *crypto_metadata_as_EncryptionWithFooterKey() const {
    return crypto_metadata_type() == parquet2::ColumnCryptoMetadata_EncryptionWithFooterKey ? static_cast<const parquet2::EncryptionWithFooterKey *>(crypto_metadata()) : nullptr;
  }
  const parquet2::EncryptionWithColumnKey *crypto_metadata_as_EncryptionWithColumnKey() const {
    return crypto_metadata_type() == parquet2::ColumnCryptoMetadata_EncryptionWithColumnKey ? static_cast<const parquet2::EncryptionWithColumnKey *>(crypto_metadata()) : nullptr;
  }
  const flatbuffers::Vector<int8_t> *encrypted_column_metadata() const {
    return GetPointer<const flatbuffers::Vector<int8_t> *>(VT_ENCRYPTED_COLUMN_METADATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_FILE_PATH) &&
           verifier.VerifyString(file_path()) &&
           VerifyField<int64_t>(verifier, VT_FILE_OFFSET, sizeof(int64_t)) &&
           VerifyOffset(verifier, VT_META_DATA) &&
           verifier.VerifyTable(meta_data()) &&
           VerifyField<int64_t>(verifier, VT_OFFSET_INDEX_OFFSET, sizeof(int64_t)) &&
           VerifyField<int32_t>(verifier, VT_OFFSET_INDEX_LENGTH, sizeof(int32_t)) &&
           VerifyField<int64_t>(verifier, VT_COLUMN_INDEX_OFFSET, sizeof(int64_t)) &&
           VerifyField<int32_t>(verifier, VT_COLUMN_INDEX_LENGTH, sizeof(int32_t)) &&
           VerifyField<uint8_t>(verifier, VT_CRYPTO_METADATA_TYPE, sizeof(uint8_t)) &&
           VerifyOffset(verifier, VT_CRYPTO_METADATA) &&
           VerifyColumnCryptoMetadata(verifier, crypto_metadata(), crypto_metadata_type()) &&
           VerifyOffset(verifier, VT_ENCRYPTED_COLUMN_METADATA) &&
           verifier.VerifyVector(encrypted_column_metadata()) &&
           verifier.EndTable();
  }
};

template<> inline const parquet2::EncryptionWithFooterKey *ColumnChunk::crypto_metadata_as<parquet2::EncryptionWithFooterKey>() const {
  return crypto_metadata_as_EncryptionWithFooterKey();
}

template<> inline const parquet2::EncryptionWithColumnKey *ColumnChunk::crypto_metadata_as<parquet2::EncryptionWithColumnKey>() const {
  return crypto_metadata_as_EncryptionWithColumnKey();
}

struct ColumnChunkBuilder {
  typedef ColumnChunk Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_file_path(flatbuffers::Offset<flatbuffers::String> file_path) {
    fbb_.AddOffset(ColumnChunk::VT_FILE_PATH, file_path);
  }
  void add_file_offset(int64_t file_offset) {
    fbb_.AddElement<int64_t>(ColumnChunk::VT_FILE_OFFSET, file_offset, 0);
  }
  void add_meta_data(flatbuffers::Offset<parquet2::ColumnMetadata> meta_data) {
    fbb_.AddOffset(ColumnChunk::VT_META_DATA, meta_data);
  }
  void add_offset_index_offset(int64_t offset_index_offset) {
    fbb_.AddElement<int64_t>(ColumnChunk::VT_OFFSET_INDEX_OFFSET, offset_index_offset, -1LL);
  }
  void add_offset_index_length(int32_t offset_index_length) {
    fbb_.AddElement<int32_t>(ColumnChunk::VT_OFFSET_INDEX_LENGTH, offset_index_length, -1);
  }
  void add_column_index_offset(int64_t column_index_offset) {
    fbb_.AddElement<int64_t>(ColumnChunk::VT_COLUMN_INDEX_OFFSET, column_index_offset, -1LL);
  }
  void add_column_index_length(int32_t column_index_length) {
    fbb_.AddElement<int32_t>(ColumnChunk::VT_COLUMN_INDEX_LENGTH, column_index_length, -1);
  }
  void add_crypto_metadata_type(parquet2::ColumnCryptoMetadata crypto_metadata_type) {
    fbb_.AddElement<uint8_t>(ColumnChunk::VT_CRYPTO_METADATA_TYPE, static_cast<uint8_t>(crypto_metadata_type), 0);
  }
  void add_crypto_metadata(flatbuffers::Offset<void> crypto_metadata) {
    fbb_.AddOffset(ColumnChunk::VT_CRYPTO_METADATA, crypto_metadata);
  }
  void add_encrypted_column_metadata(flatbuffers::Offset<flatbuffers::Vector<int8_t>> encrypted_column_metadata) {
    fbb_.AddOffset(ColumnChunk::VT_ENCRYPTED_COLUMN_METADATA, encrypted_column_metadata);
  }
  explicit ColumnChunkBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ColumnChunk> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ColumnChunk>(end);
    return o;
  }
};

inline flatbuffers::Offset<ColumnChunk> CreateColumnChunk(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> file_path = 0,
    int64_t file_offset = 0,
    flatbuffers::Offset<parquet2::ColumnMetadata> meta_data = 0,
    int64_t offset_index_offset = -1LL,
    int32_t offset_index_length = -1,
    int64_t column_index_offset = -1LL,
    int32_t column_index_length = -1,
    parquet2::ColumnCryptoMetadata crypto_metadata_type = parquet2::ColumnCryptoMetadata_NONE,
    flatbuffers::Offset<void> crypto_metadata = 0,
    flatbuffers::Offset<flatbuffers::Vector<int8_t>> encrypted_column_metadata = 0) {
  ColumnChunkBuilder builder_(_fbb);
  builder_.add_column_index_offset(column_index_offset);
  builder_.add_offset_index_offset(offset_index_offset);
  builder_.add_file_offset(file_offset);
  builder_.add_encrypted_column_metadata(encrypted_column_metadata);
  builder_.add_crypto_metadata(crypto_metadata);
  builder_.add_column_index_length(column_index_length);
  builder_.add_offset_index_length(offset_index_length);
  builder_.add_meta_data(meta_data);
  builder_.add_file_path(file_path);
  builder_.add_crypto_metadata_type(crypto_metadata_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<ColumnChunk> CreateColumnChunkDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *file_path = nullptr,
    int64_t file_offset = 0,
    flatbuffers::Offset<parquet2::ColumnMetadata> meta_data = 0,
    int64_t offset_index_offset = -1LL,
    int32_t offset_index_length = -1,
    int64_t column_index_offset = -1LL,
    int32_t column_index_length = -1,
    parquet2::ColumnCryptoMetadata crypto_metadata_type = parquet2::ColumnCryptoMetadata_NONE,
    flatbuffers::Offset<void> crypto_metadata = 0,
    const std::vector<int8_t> *encrypted_column_metadata = nullptr) {
  auto file_path__ = file_path ? _fbb.CreateString(file_path) : 0;
  auto encrypted_column_metadata__ = encrypted_column_metadata ? _fbb.CreateVector<int8_t>(*encrypted_column_metadata) : 0;
  return parquet2::CreateColumnChunk(
      _fbb,
      file_path__,
      file_offset,
      meta_data,
      offset_index_offset,
      offset_index_length,
      column_index_offset,
      column_index_length,
      crypto_metadata_type,
      crypto_metadata,
      encrypted_column_metadata__);
}

struct RowGroup FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RowGroupBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_COLUMNS = 4,
    VT_TOTAL_BYTE_SIZE = 6,
    VT_NUM_ROWS = 8,
    VT_SORTING_COLUMNS = 10,
    VT_FILE_OFFSET = 12,
    VT_TOTAL_COMPRESSED_SIZE = 14,
    VT_ORDINAL = 16
  };
  const flatbuffers::Vector<flatbuffers::Offset<parquet2::ColumnChunk>> *columns() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<parquet2::ColumnChunk>> *>(VT_COLUMNS);
  }
  int64_t total_byte_size() const {
    return GetField<int64_t>(VT_TOTAL_BYTE_SIZE, 0);
  }
  int64_t num_rows() const {
    return GetField<int64_t>(VT_NUM_ROWS, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<parquet2::SortingColumn>> *sorting_columns() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<parquet2::SortingColumn>> *>(VT_SORTING_COLUMNS);
  }
  int64_t file_offset() const {
    return GetField<int64_t>(VT_FILE_OFFSET, -1LL);
  }
  int64_t total_compressed_size() const {
    return GetField<int64_t>(VT_TOTAL_COMPRESSED_SIZE, -1LL);
  }
  int16_t ordinal() const {
    return GetField<int16_t>(VT_ORDINAL, -1);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_COLUMNS) &&
           verifier.VerifyVector(columns()) &&
           verifier.VerifyVectorOfTables(columns()) &&
           VerifyField<int64_t>(verifier, VT_TOTAL_BYTE_SIZE, sizeof(int64_t)) &&
           VerifyField<int64_t>(verifier, VT_NUM_ROWS, sizeof(int64_t)) &&
           VerifyOffset(verifier, VT_SORTING_COLUMNS) &&
           verifier.VerifyVector(sorting_columns()) &&
           verifier.VerifyVectorOfTables(sorting_columns()) &&
           VerifyField<int64_t>(verifier, VT_FILE_OFFSET, sizeof(int64_t)) &&
           VerifyField<int64_t>(verifier, VT_TOTAL_COMPRESSED_SIZE, sizeof(int64_t)) &&
           VerifyField<int16_t>(verifier, VT_ORDINAL, sizeof(int16_t)) &&
           verifier.EndTable();
  }
};

struct RowGroupBuilder {
  typedef RowGroup Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_columns(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<parquet2::ColumnChunk>>> columns) {
    fbb_.AddOffset(RowGroup::VT_COLUMNS, columns);
  }
  void add_total_byte_size(int64_t total_byte_size) {
    fbb_.AddElement<int64_t>(RowGroup::VT_TOTAL_BYTE_SIZE, total_byte_size, 0);
  }
  void add_num_rows(int64_t num_rows) {
    fbb_.AddElement<int64_t>(RowGroup::VT_NUM_ROWS, num_rows, 0);
  }
  void add_sorting_columns(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<parquet2::SortingColumn>>> sorting_columns) {
    fbb_.AddOffset(RowGroup::VT_SORTING_COLUMNS, sorting_columns);
  }
  void add_file_offset(int64_t file_offset) {
    fbb_.AddElement<int64_t>(RowGroup::VT_FILE_OFFSET, file_offset, -1LL);
  }
  void add_total_compressed_size(int64_t total_compressed_size) {
    fbb_.AddElement<int64_t>(RowGroup::VT_TOTAL_COMPRESSED_SIZE, total_compressed_size, -1LL);
  }
  void add_ordinal(int16_t ordinal) {
    fbb_.AddElement<int16_t>(RowGroup::VT_ORDINAL, ordinal, -1);
  }
  explicit RowGroupBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<RowGroup> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RowGroup>(end);
    return o;
  }
};

inline flatbuffers::Offset<RowGroup> CreateRowGroup(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<parquet2::ColumnChunk>>> columns = 0,
    int64_t total_byte_size = 0,
    int64_t num_rows = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<parquet2::SortingColumn>>> sorting_columns = 0,
    int64_t file_offset = -1LL,
    int64_t total_compressed_size = -1LL,
    int16_t ordinal = -1) {
  RowGroupBuilder builder_(_fbb);
  builder_.add_total_compressed_size(total_compressed_size);
  builder_.add_file_offset(file_offset);
  builder_.add_num_rows(num_rows);
  builder_.add_total_byte_size(total_byte_size);
  builder_.add_sorting_columns(sorting_columns);
  builder_.add_columns(columns);
  builder_.add_ordinal(ordinal);
  return builder_.Finish();
}

inline flatbuffers::Offset<RowGroup> CreateRowGroupDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<parquet2::ColumnChunk>> *columns = nullptr,
    int64_t total_byte_size = 0,
    int64_t num_rows = 0,
    const std::vector<flatbuffers::Offset<parquet2::SortingColumn>> *sorting_columns = nullptr,
    int64_t file_offset = -1LL,
    int64_t total_compressed_size = -1LL,
    int16_t ordinal = -1) {
  auto columns__ = columns ? _fbb.CreateVector<flatbuffers::Offset<parquet2::ColumnChunk>>(*columns) : 0;
  auto sorting_columns__ = sorting_columns ? _fbb.CreateVector<flatbuffers::Offset<parquet2::SortingColumn>>(*sorting_columns) : 0;
  return parquet2::CreateRowGroup(
      _fbb,
      columns__,
      total_byte_size,
      num_rows,
      sorting_columns__,
      file_offset,
      total_compressed_size,
      ordinal);
}

struct TypeDefinedOrder FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TypeDefinedOrderBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct TypeDefinedOrderBuilder {
  typedef TypeDefinedOrder Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit TypeDefinedOrderBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<TypeDefinedOrder> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TypeDefinedOrder>(end);
    return o;
  }
};

inline flatbuffers::Offset<TypeDefinedOrder> CreateTypeDefinedOrder(
    flatbuffers::FlatBufferBuilder &_fbb) {
  TypeDefinedOrderBuilder builder_(_fbb);
  return builder_.Finish();
}

struct PageLocation FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PageLocationBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OFFSET = 4,
    VT_COMPRESSED_PAGE_SIZE = 6,
    VT_FIRST_ROW_INDEX = 8
  };
  int64_t offset() const {
    return GetField<int64_t>(VT_OFFSET, 0);
  }
  int32_t compressed_page_size() const {
    return GetField<int32_t>(VT_COMPRESSED_PAGE_SIZE, 0);
  }
  int32_t first_row_index() const {
    return GetField<int32_t>(VT_FIRST_ROW_INDEX, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_OFFSET, sizeof(int64_t)) &&
           VerifyField<int32_t>(verifier, VT_COMPRESSED_PAGE_SIZE, sizeof(int32_t)) &&
           VerifyField<int32_t>(verifier, VT_FIRST_ROW_INDEX, sizeof(int32_t)) &&
           verifier.EndTable();
  }
};

struct PageLocationBuilder {
  typedef PageLocation Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_offset(int64_t offset) {
    fbb_.AddElement<int64_t>(PageLocation::VT_OFFSET, offset, 0);
  }
  void add_compressed_page_size(int32_t compressed_page_size) {
    fbb_.AddElement<int32_t>(PageLocation::VT_COMPRESSED_PAGE_SIZE, compressed_page_size, 0);
  }
  void add_first_row_index(int32_t first_row_index) {
    fbb_.AddElement<int32_t>(PageLocation::VT_FIRST_ROW_INDEX, first_row_index, 0);
  }
  explicit PageLocationBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<PageLocation> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PageLocation>(end);
    return o;
  }
};

inline flatbuffers::Offset<PageLocation> CreatePageLocation(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t offset = 0,
    int32_t compressed_page_size = 0,
    int32_t first_row_index = 0) {
  PageLocationBuilder builder_(_fbb);
  builder_.add_offset(offset);
  builder_.add_first_row_index(first_row_index);
  builder_.add_compressed_page_size(compressed_page_size);
  return builder_.Finish();
}

struct OffsetIndex FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef OffsetIndexBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PAGE_LOCATIONS = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<parquet2::PageLocation>> *page_locations() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<parquet2::PageLocation>> *>(VT_PAGE_LOCATIONS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PAGE_LOCATIONS) &&
           verifier.VerifyVector(page_locations()) &&
           verifier.VerifyVectorOfTables(page_locations()) &&
           verifier.EndTable();
  }
};

struct OffsetIndexBuilder {
  typedef OffsetIndex Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_page_locations(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<parquet2::PageLocation>>> page_locations) {
    fbb_.AddOffset(OffsetIndex::VT_PAGE_LOCATIONS, page_locations);
  }
  explicit OffsetIndexBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<OffsetIndex> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<OffsetIndex>(end);
    return o;
  }
};

inline flatbuffers::Offset<OffsetIndex> CreateOffsetIndex(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<parquet2::PageLocation>>> page_locations = 0) {
  OffsetIndexBuilder builder_(_fbb);
  builder_.add_page_locations(page_locations);
  return builder_.Finish();
}

inline flatbuffers::Offset<OffsetIndex> CreateOffsetIndexDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<parquet2::PageLocation>> *page_locations = nullptr) {
  auto page_locations__ = page_locations ? _fbb.CreateVector<flatbuffers::Offset<parquet2::PageLocation>>(*page_locations) : 0;
  return parquet2::CreateOffsetIndex(
      _fbb,
      page_locations__);
}

struct ColumnIndex FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ColumnIndexBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NULL_PAGES = 4,
    VT_MIN_VALUES = 6,
    VT_MAX_VALUES = 8,
    VT_BOUNDARY_ORDER = 10,
    VT_NULL_COUNTS = 12
  };
  const flatbuffers::Vector<uint8_t> *null_pages() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_NULL_PAGES);
  }
  const flatbuffers::Vector<flatbuffers::Offset<parquet2::Value>> *min_values() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<parquet2::Value>> *>(VT_MIN_VALUES);
  }
  const flatbuffers::Vector<flatbuffers::Offset<parquet2::Value>> *max_values() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<parquet2::Value>> *>(VT_MAX_VALUES);
  }
  parquet2::BoundaryOrder boundary_order() const {
    return static_cast<parquet2::BoundaryOrder>(GetField<int8_t>(VT_BOUNDARY_ORDER, 0));
  }
  const flatbuffers::Vector<int64_t> *null_counts() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_NULL_COUNTS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NULL_PAGES) &&
           verifier.VerifyVector(null_pages()) &&
           VerifyOffset(verifier, VT_MIN_VALUES) &&
           verifier.VerifyVector(min_values()) &&
           verifier.VerifyVectorOfTables(min_values()) &&
           VerifyOffset(verifier, VT_MAX_VALUES) &&
           verifier.VerifyVector(max_values()) &&
           verifier.VerifyVectorOfTables(max_values()) &&
           VerifyField<int8_t>(verifier, VT_BOUNDARY_ORDER, sizeof(int8_t)) &&
           VerifyOffset(verifier, VT_NULL_COUNTS) &&
           verifier.VerifyVector(null_counts()) &&
           verifier.EndTable();
  }
};

struct ColumnIndexBuilder {
  typedef ColumnIndex Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_null_pages(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> null_pages) {
    fbb_.AddOffset(ColumnIndex::VT_NULL_PAGES, null_pages);
  }
  void add_min_values(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<parquet2::Value>>> min_values) {
    fbb_.AddOffset(ColumnIndex::VT_MIN_VALUES, min_values);
  }
  void add_max_values(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<parquet2::Value>>> max_values) {
    fbb_.AddOffset(ColumnIndex::VT_MAX_VALUES, max_values);
  }
  void add_boundary_order(parquet2::BoundaryOrder boundary_order) {
    fbb_.AddElement<int8_t>(ColumnIndex::VT_BOUNDARY_ORDER, static_cast<int8_t>(boundary_order), 0);
  }
  void add_null_counts(flatbuffers::Offset<flatbuffers::Vector<int64_t>> null_counts) {
    fbb_.AddOffset(ColumnIndex::VT_NULL_COUNTS, null_counts);
  }
  explicit ColumnIndexBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ColumnIndex> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ColumnIndex>(end);
    return o;
  }
};

inline flatbuffers::Offset<ColumnIndex> CreateColumnIndex(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> null_pages = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<parquet2::Value>>> min_values = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<parquet2::Value>>> max_values = 0,
    parquet2::BoundaryOrder boundary_order = parquet2::BoundaryOrder_UNORDERED,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> null_counts = 0) {
  ColumnIndexBuilder builder_(_fbb);
  builder_.add_null_counts(null_counts);
  builder_.add_max_values(max_values);
  builder_.add_min_values(min_values);
  builder_.add_null_pages(null_pages);
  builder_.add_boundary_order(boundary_order);
  return builder_.Finish();
}

inline flatbuffers::Offset<ColumnIndex> CreateColumnIndexDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *null_pages = nullptr,
    const std::vector<flatbuffers::Offset<parquet2::Value>> *min_values = nullptr,
    const std::vector<flatbuffers::Offset<parquet2::Value>> *max_values = nullptr,
    parquet2::BoundaryOrder boundary_order = parquet2::BoundaryOrder_UNORDERED,
    const std::vector<int64_t> *null_counts = nullptr) {
  auto null_pages__ = null_pages ? _fbb.CreateVector<uint8_t>(*null_pages) : 0;
  auto min_values__ = min_values ? _fbb.CreateVector<flatbuffers::Offset<parquet2::Value>>(*min_values) : 0;
  auto max_values__ = max_values ? _fbb.CreateVector<flatbuffers::Offset<parquet2::Value>>(*max_values) : 0;
  auto null_counts__ = null_counts ? _fbb.CreateVector<int64_t>(*null_counts) : 0;
  return parquet2::CreateColumnIndex(
      _fbb,
      null_pages__,
      min_values__,
      max_values__,
      boundary_order,
      null_counts__);
}

struct AesGcmV1 FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AesGcmV1Builder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_AAD_PREFIX = 4,
    VT_AAD_FILE_UNIQUE = 6,
    VT_SUPPLY_AAD_PREFIX = 8
  };
  const flatbuffers::Vector<int8_t> *aad_prefix() const {
    return GetPointer<const flatbuffers::Vector<int8_t> *>(VT_AAD_PREFIX);
  }
  const flatbuffers::Vector<int8_t> *aad_file_unique() const {
    return GetPointer<const flatbuffers::Vector<int8_t> *>(VT_AAD_FILE_UNIQUE);
  }
  bool supply_aad_prefix() const {
    return GetField<uint8_t>(VT_SUPPLY_AAD_PREFIX, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_AAD_PREFIX) &&
           verifier.VerifyVector(aad_prefix()) &&
           VerifyOffset(verifier, VT_AAD_FILE_UNIQUE) &&
           verifier.VerifyVector(aad_file_unique()) &&
           VerifyField<uint8_t>(verifier, VT_SUPPLY_AAD_PREFIX, sizeof(uint8_t)) &&
           verifier.EndTable();
  }
};

struct AesGcmV1Builder {
  typedef AesGcmV1 Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_aad_prefix(flatbuffers::Offset<flatbuffers::Vector<int8_t>> aad_prefix) {
    fbb_.AddOffset(AesGcmV1::VT_AAD_PREFIX, aad_prefix);
  }
  void add_aad_file_unique(flatbuffers::Offset<flatbuffers::Vector<int8_t>> aad_file_unique) {
    fbb_.AddOffset(AesGcmV1::VT_AAD_FILE_UNIQUE, aad_file_unique);
  }
  void add_supply_aad_prefix(bool supply_aad_prefix) {
    fbb_.AddElement<uint8_t>(AesGcmV1::VT_SUPPLY_AAD_PREFIX, static_cast<uint8_t>(supply_aad_prefix), 0);
  }
  explicit AesGcmV1Builder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<AesGcmV1> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AesGcmV1>(end);
    return o;
  }
};

inline flatbuffers::Offset<AesGcmV1> CreateAesGcmV1(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int8_t>> aad_prefix = 0,
    flatbuffers::Offset<flatbuffers::Vector<int8_t>> aad_file_unique = 0,
    bool supply_aad_prefix = false) {
  AesGcmV1Builder builder_(_fbb);
  builder_.add_aad_file_unique(aad_file_unique);
  builder_.add_aad_prefix(aad_prefix);
  builder_.add_supply_aad_prefix(supply_aad_prefix);
  return builder_.Finish();
}

inline flatbuffers::Offset<AesGcmV1> CreateAesGcmV1Direct(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int8_t> *aad_prefix = nullptr,
    const std::vector<int8_t> *aad_file_unique = nullptr,
    bool supply_aad_prefix = false) {
  auto aad_prefix__ = aad_prefix ? _fbb.CreateVector<int8_t>(*aad_prefix) : 0;
  auto aad_file_unique__ = aad_file_unique ? _fbb.CreateVector<int8_t>(*aad_file_unique) : 0;
  return parquet2::CreateAesGcmV1(
      _fbb,
      aad_prefix__,
      aad_file_unique__,
      supply_aad_prefix);
}

struct AesGcmCtrV1 FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AesGcmCtrV1Builder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_AAD_PREFIX = 4,
    VT_AAD_FILE_UNIQUE = 6,
    VT_SUPPLY_AAD_PREFIX = 8
  };
  const flatbuffers::Vector<int8_t> *aad_prefix() const {
    return GetPointer<const flatbuffers::Vector<int8_t> *>(VT_AAD_PREFIX);
  }
  const flatbuffers::Vector<int8_t> *aad_file_unique() const {
    return GetPointer<const flatbuffers::Vector<int8_t> *>(VT_AAD_FILE_UNIQUE);
  }
  bool supply_aad_prefix() const {
    return GetField<uint8_t>(VT_SUPPLY_AAD_PREFIX, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_AAD_PREFIX) &&
           verifier.VerifyVector(aad_prefix()) &&
           VerifyOffset(verifier, VT_AAD_FILE_UNIQUE) &&
           verifier.VerifyVector(aad_file_unique()) &&
           VerifyField<uint8_t>(verifier, VT_SUPPLY_AAD_PREFIX, sizeof(uint8_t)) &&
           verifier.EndTable();
  }
};

struct AesGcmCtrV1Builder {
  typedef AesGcmCtrV1 Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_aad_prefix(flatbuffers::Offset<flatbuffers::Vector<int8_t>> aad_prefix) {
    fbb_.AddOffset(AesGcmCtrV1::VT_AAD_PREFIX, aad_prefix);
  }
  void add_aad_file_unique(flatbuffers::Offset<flatbuffers::Vector<int8_t>> aad_file_unique) {
    fbb_.AddOffset(AesGcmCtrV1::VT_AAD_FILE_UNIQUE, aad_file_unique);
  }
  void add_supply_aad_prefix(bool supply_aad_prefix) {
    fbb_.AddElement<uint8_t>(AesGcmCtrV1::VT_SUPPLY_AAD_PREFIX, static_cast<uint8_t>(supply_aad_prefix), 0);
  }
  explicit AesGcmCtrV1Builder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<AesGcmCtrV1> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AesGcmCtrV1>(end);
    return o;
  }
};

inline flatbuffers::Offset<AesGcmCtrV1> CreateAesGcmCtrV1(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int8_t>> aad_prefix = 0,
    flatbuffers::Offset<flatbuffers::Vector<int8_t>> aad_file_unique = 0,
    bool supply_aad_prefix = false) {
  AesGcmCtrV1Builder builder_(_fbb);
  builder_.add_aad_file_unique(aad_file_unique);
  builder_.add_aad_prefix(aad_prefix);
  builder_.add_supply_aad_prefix(supply_aad_prefix);
  return builder_.Finish();
}

inline flatbuffers::Offset<AesGcmCtrV1> CreateAesGcmCtrV1Direct(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int8_t> *aad_prefix = nullptr,
    const std::vector<int8_t> *aad_file_unique = nullptr,
    bool supply_aad_prefix = false) {
  auto aad_prefix__ = aad_prefix ? _fbb.CreateVector<int8_t>(*aad_prefix) : 0;
  auto aad_file_unique__ = aad_file_unique ? _fbb.CreateVector<int8_t>(*aad_file_unique) : 0;
  return parquet2::CreateAesGcmCtrV1(
      _fbb,
      aad_prefix__,
      aad_file_unique__,
      supply_aad_prefix);
}

struct FileMetaData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FileMetaDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VERSION = 4,
    VT_SCHEMA = 6,
    VT_NUM_ROWS = 8,
    VT_ROW_GROUPS = 10,
    VT_KEY_VALUE_METADATA = 12,
    VT_CREATED_BY = 14,
    VT_ENCRYPTION_ALGORITHM_TYPE = 16,
    VT_ENCRYPTION_ALGORITHM = 18,
    VT_FOOTER_SIGNING_KEY_METADATA = 20
  };
  int32_t version() const {
    return GetField<int32_t>(VT_VERSION, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<parquet2::SchemaElement>> *schema() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<parquet2::SchemaElement>> *>(VT_SCHEMA);
  }
  int64_t num_rows() const {
    return GetField<int64_t>(VT_NUM_ROWS, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<parquet2::RowGroup>> *row_groups() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<parquet2::RowGroup>> *>(VT_ROW_GROUPS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<parquet2::KeyValue>> *key_value_metadata() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<parquet2::KeyValue>> *>(VT_KEY_VALUE_METADATA);
  }
  const flatbuffers::String *created_by() const {
    return GetPointer<const flatbuffers::String *>(VT_CREATED_BY);
  }
  parquet2::EncryptionAlgorithm encryption_algorithm_type() const {
    return static_cast<parquet2::EncryptionAlgorithm>(GetField<uint8_t>(VT_ENCRYPTION_ALGORITHM_TYPE, 0));
  }
  const void *encryption_algorithm() const {
    return GetPointer<const void *>(VT_ENCRYPTION_ALGORITHM);
  }
  template<typename T> const T *encryption_algorithm_as() const;
  const parquet2::AesGcmV1 *encryption_algorithm_as_AesGcmV1() const {
    return encryption_algorithm_type() == parquet2::EncryptionAlgorithm_AesGcmV1 ? static_cast<const parquet2::AesGcmV1 *>(encryption_algorithm()) : nullptr;
  }
  const parquet2::AesGcmCtrV1 *encryption_algorithm_as_AesGcmCtrV1() const {
    return encryption_algorithm_type() == parquet2::EncryptionAlgorithm_AesGcmCtrV1 ? static_cast<const parquet2::AesGcmCtrV1 *>(encryption_algorithm()) : nullptr;
  }
  const flatbuffers::Vector<int8_t> *footer_signing_key_metadata() const {
    return GetPointer<const flatbuffers::Vector<int8_t> *>(VT_FOOTER_SIGNING_KEY_METADATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_VERSION, sizeof(int32_t)) &&
           VerifyOffset(verifier, VT_SCHEMA) &&
           verifier.VerifyVector(schema()) &&
           verifier.VerifyVectorOfTables(schema()) &&
           VerifyField<int64_t>(verifier, VT_NUM_ROWS, sizeof(int64_t)) &&
           VerifyOffset(verifier, VT_ROW_GROUPS) &&
           verifier.VerifyVector(row_groups()) &&
           verifier.VerifyVectorOfTables(row_groups()) &&
           VerifyOffset(verifier, VT_KEY_VALUE_METADATA) &&
           verifier.VerifyVector(key_value_metadata()) &&
           verifier.VerifyVectorOfTables(key_value_metadata()) &&
           VerifyOffset(verifier, VT_CREATED_BY) &&
           verifier.VerifyString(created_by()) &&
           VerifyField<uint8_t>(verifier, VT_ENCRYPTION_ALGORITHM_TYPE, sizeof(uint8_t)) &&
           VerifyOffset(verifier, VT_ENCRYPTION_ALGORITHM) &&
           VerifyEncryptionAlgorithm(verifier, encryption_algorithm(), encryption_algorithm_type()) &&
           VerifyOffset(verifier, VT_FOOTER_SIGNING_KEY_METADATA) &&
           verifier.VerifyVector(footer_signing_key_metadata()) &&
           verifier.EndTable();
  }
};

template<> inline const parquet2::AesGcmV1 *FileMetaData::encryption_algorithm_as<parquet2::AesGcmV1>() const {
  return encryption_algorithm_as_AesGcmV1();
}

template<> inline const parquet2::AesGcmCtrV1 *FileMetaData::encryption_algorithm_as<parquet2::AesGcmCtrV1>() const {
  return encryption_algorithm_as_AesGcmCtrV1();
}

struct FileMetaDataBuilder {
  typedef FileMetaData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_version(int32_t version) {
    fbb_.AddElement<int32_t>(FileMetaData::VT_VERSION, version, 0);
  }
  void add_schema(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<parquet2::SchemaElement>>> schema) {
    fbb_.AddOffset(FileMetaData::VT_SCHEMA, schema);
  }
  void add_num_rows(int64_t num_rows) {
    fbb_.AddElement<int64_t>(FileMetaData::VT_NUM_ROWS, num_rows, 0);
  }
  void add_row_groups(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<parquet2::RowGroup>>> row_groups) {
    fbb_.AddOffset(FileMetaData::VT_ROW_GROUPS, row_groups);
  }
  void add_key_value_metadata(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<parquet2::KeyValue>>> key_value_metadata) {
    fbb_.AddOffset(FileMetaData::VT_KEY_VALUE_METADATA, key_value_metadata);
  }
  void add_created_by(flatbuffers::Offset<flatbuffers::String> created_by) {
    fbb_.AddOffset(FileMetaData::VT_CREATED_BY, created_by);
  }
  void add_encryption_algorithm_type(parquet2::EncryptionAlgorithm encryption_algorithm_type) {
    fbb_.AddElement<uint8_t>(FileMetaData::VT_ENCRYPTION_ALGORITHM_TYPE, static_cast<uint8_t>(encryption_algorithm_type), 0);
  }
  void add_encryption_algorithm(flatbuffers::Offset<void> encryption_algorithm) {
    fbb_.AddOffset(FileMetaData::VT_ENCRYPTION_ALGORITHM, encryption_algorithm);
  }
  void add_footer_signing_key_metadata(flatbuffers::Offset<flatbuffers::Vector<int8_t>> footer_signing_key_metadata) {
    fbb_.AddOffset(FileMetaData::VT_FOOTER_SIGNING_KEY_METADATA, footer_signing_key_metadata);
  }
  explicit FileMetaDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<FileMetaData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FileMetaData>(end);
    return o;
  }
};

inline flatbuffers::Offset<FileMetaData> CreateFileMetaData(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t version = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<parquet2::SchemaElement>>> schema = 0,
    int64_t num_rows = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<parquet2::RowGroup>>> row_groups = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<parquet2::KeyValue>>> key_value_metadata = 0,
    flatbuffers::Offset<flatbuffers::String> created_by = 0,
    parquet2::EncryptionAlgorithm encryption_algorithm_type = parquet2::EncryptionAlgorithm_NONE,
    flatbuffers::Offset<void> encryption_algorithm = 0,
    flatbuffers::Offset<flatbuffers::Vector<int8_t>> footer_signing_key_metadata = 0) {
  FileMetaDataBuilder builder_(_fbb);
  builder_.add_num_rows(num_rows);
  builder_.add_footer_signing_key_metadata(footer_signing_key_metadata);
  builder_.add_encryption_algorithm(encryption_algorithm);
  builder_.add_created_by(created_by);
  builder_.add_key_value_metadata(key_value_metadata);
  builder_.add_row_groups(row_groups);
  builder_.add_schema(schema);
  builder_.add_version(version);
  builder_.add_encryption_algorithm_type(encryption_algorithm_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<FileMetaData> CreateFileMetaDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t version = 0,
    const std::vector<flatbuffers::Offset<parquet2::SchemaElement>> *schema = nullptr,
    int64_t num_rows = 0,
    const std::vector<flatbuffers::Offset<parquet2::RowGroup>> *row_groups = nullptr,
    const std::vector<flatbuffers::Offset<parquet2::KeyValue>> *key_value_metadata = nullptr,
    const char *created_by = nullptr,
    parquet2::EncryptionAlgorithm encryption_algorithm_type = parquet2::EncryptionAlgorithm_NONE,
    flatbuffers::Offset<void> encryption_algorithm = 0,
    const std::vector<int8_t> *footer_signing_key_metadata = nullptr) {
  auto schema__ = schema ? _fbb.CreateVector<flatbuffers::Offset<parquet2::SchemaElement>>(*schema) : 0;
  auto row_groups__ = row_groups ? _fbb.CreateVector<flatbuffers::Offset<parquet2::RowGroup>>(*row_groups) : 0;
  auto key_value_metadata__ = key_value_metadata ? _fbb.CreateVector<flatbuffers::Offset<parquet2::KeyValue>>(*key_value_metadata) : 0;
  auto created_by__ = created_by ? _fbb.CreateString(created_by) : 0;
  auto footer_signing_key_metadata__ = footer_signing_key_metadata ? _fbb.CreateVector<int8_t>(*footer_signing_key_metadata) : 0;
  return parquet2::CreateFileMetaData(
      _fbb,
      version,
      schema__,
      num_rows,
      row_groups__,
      key_value_metadata__,
      created_by__,
      encryption_algorithm_type,
      encryption_algorithm,
      footer_signing_key_metadata__);
}

struct FileCryptoMetaData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FileCryptoMetaDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ENCRYPTION_ALGORITHM_TYPE = 4,
    VT_ENCRYPTION_ALGORITHM = 6,
    VT_KEY_METADATA = 8
  };
  parquet2::EncryptionAlgorithm encryption_algorithm_type() const {
    return static_cast<parquet2::EncryptionAlgorithm>(GetField<uint8_t>(VT_ENCRYPTION_ALGORITHM_TYPE, 0));
  }
  const void *encryption_algorithm() const {
    return GetPointer<const void *>(VT_ENCRYPTION_ALGORITHM);
  }
  template<typename T> const T *encryption_algorithm_as() const;
  const parquet2::AesGcmV1 *encryption_algorithm_as_AesGcmV1() const {
    return encryption_algorithm_type() == parquet2::EncryptionAlgorithm_AesGcmV1 ? static_cast<const parquet2::AesGcmV1 *>(encryption_algorithm()) : nullptr;
  }
  const parquet2::AesGcmCtrV1 *encryption_algorithm_as_AesGcmCtrV1() const {
    return encryption_algorithm_type() == parquet2::EncryptionAlgorithm_AesGcmCtrV1 ? static_cast<const parquet2::AesGcmCtrV1 *>(encryption_algorithm()) : nullptr;
  }
  const flatbuffers::Vector<int8_t> *key_metadata() const {
    return GetPointer<const flatbuffers::Vector<int8_t> *>(VT_KEY_METADATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_ENCRYPTION_ALGORITHM_TYPE, sizeof(uint8_t)) &&
           VerifyOffset(verifier, VT_ENCRYPTION_ALGORITHM) &&
           VerifyEncryptionAlgorithm(verifier, encryption_algorithm(), encryption_algorithm_type()) &&
           VerifyOffset(verifier, VT_KEY_METADATA) &&
           verifier.VerifyVector(key_metadata()) &&
           verifier.EndTable();
  }
};

template<> inline const parquet2::AesGcmV1 *FileCryptoMetaData::encryption_algorithm_as<parquet2::AesGcmV1>() const {
  return encryption_algorithm_as_AesGcmV1();
}

template<> inline const parquet2::AesGcmCtrV1 *FileCryptoMetaData::encryption_algorithm_as<parquet2::AesGcmCtrV1>() const {
  return encryption_algorithm_as_AesGcmCtrV1();
}

struct FileCryptoMetaDataBuilder {
  typedef FileCryptoMetaData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_encryption_algorithm_type(parquet2::EncryptionAlgorithm encryption_algorithm_type) {
    fbb_.AddElement<uint8_t>(FileCryptoMetaData::VT_ENCRYPTION_ALGORITHM_TYPE, static_cast<uint8_t>(encryption_algorithm_type), 0);
  }
  void add_encryption_algorithm(flatbuffers::Offset<void> encryption_algorithm) {
    fbb_.AddOffset(FileCryptoMetaData::VT_ENCRYPTION_ALGORITHM, encryption_algorithm);
  }
  void add_key_metadata(flatbuffers::Offset<flatbuffers::Vector<int8_t>> key_metadata) {
    fbb_.AddOffset(FileCryptoMetaData::VT_KEY_METADATA, key_metadata);
  }
  explicit FileCryptoMetaDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<FileCryptoMetaData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FileCryptoMetaData>(end);
    return o;
  }
};

inline flatbuffers::Offset<FileCryptoMetaData> CreateFileCryptoMetaData(
    flatbuffers::FlatBufferBuilder &_fbb,
    parquet2::EncryptionAlgorithm encryption_algorithm_type = parquet2::EncryptionAlgorithm_NONE,
    flatbuffers::Offset<void> encryption_algorithm = 0,
    flatbuffers::Offset<flatbuffers::Vector<int8_t>> key_metadata = 0) {
  FileCryptoMetaDataBuilder builder_(_fbb);
  builder_.add_key_metadata(key_metadata);
  builder_.add_encryption_algorithm(encryption_algorithm);
  builder_.add_encryption_algorithm_type(encryption_algorithm_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<FileCryptoMetaData> CreateFileCryptoMetaDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    parquet2::EncryptionAlgorithm encryption_algorithm_type = parquet2::EncryptionAlgorithm_NONE,
    flatbuffers::Offset<void> encryption_algorithm = 0,
    const std::vector<int8_t> *key_metadata = nullptr) {
  auto key_metadata__ = key_metadata ? _fbb.CreateVector<int8_t>(*key_metadata) : 0;
  return parquet2::CreateFileCryptoMetaData(
      _fbb,
      encryption_algorithm_type,
      encryption_algorithm,
      key_metadata__);
}

inline bool VerifyTimeUnit(flatbuffers::Verifier &verifier, const void *obj, TimeUnit type) {
  switch (type) {
    case TimeUnit_NONE: {
      return true;
    }
    case TimeUnit_MilliSeconds: {
      auto ptr = reinterpret_cast<const parquet2::MilliSeconds *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case TimeUnit_MicroSeconds: {
      auto ptr = reinterpret_cast<const parquet2::MicroSeconds *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case TimeUnit_NanoSeconds: {
      auto ptr = reinterpret_cast<const parquet2::NanoSeconds *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyTimeUnitVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyTimeUnit(
        verifier,  values->Get(i), types->GetEnum<TimeUnit>(i))) {
      return false;
    }
  }
  return true;
}

inline bool VerifyLogicalType(flatbuffers::Verifier &verifier, const void *obj, LogicalType type) {
  switch (type) {
    case LogicalType_NONE: {
      return true;
    }
    case LogicalType_StringType: {
      auto ptr = reinterpret_cast<const parquet2::StringType *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case LogicalType_MapType: {
      auto ptr = reinterpret_cast<const parquet2::MapType *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case LogicalType_ListType: {
      auto ptr = reinterpret_cast<const parquet2::ListType *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case LogicalType_EnumType: {
      auto ptr = reinterpret_cast<const parquet2::EnumType *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case LogicalType_DecimalType: {
      auto ptr = reinterpret_cast<const parquet2::DecimalType *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case LogicalType_DateType: {
      auto ptr = reinterpret_cast<const parquet2::DateType *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case LogicalType_TimeType: {
      auto ptr = reinterpret_cast<const parquet2::TimeType *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case LogicalType_TimestampType: {
      auto ptr = reinterpret_cast<const parquet2::TimestampType *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case LogicalType_IntType: {
      auto ptr = reinterpret_cast<const parquet2::IntType *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case LogicalType_NullType: {
      auto ptr = reinterpret_cast<const parquet2::NullType *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case LogicalType_JsonType: {
      auto ptr = reinterpret_cast<const parquet2::JsonType *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case LogicalType_BsonType: {
      auto ptr = reinterpret_cast<const parquet2::BsonType *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case LogicalType_UUIDType: {
      auto ptr = reinterpret_cast<const parquet2::UUIDType *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyLogicalTypeVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyLogicalType(
        verifier,  values->Get(i), types->GetEnum<LogicalType>(i))) {
      return false;
    }
  }
  return true;
}

inline bool VerifyBloomFilterAlgorithm(flatbuffers::Verifier &verifier, const void *obj, BloomFilterAlgorithm type) {
  switch (type) {
    case BloomFilterAlgorithm_NONE: {
      return true;
    }
    case BloomFilterAlgorithm_SplitBlockAlgorithm: {
      auto ptr = reinterpret_cast<const parquet2::SplitBlockAlgorithm *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyBloomFilterAlgorithmVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyBloomFilterAlgorithm(
        verifier,  values->Get(i), types->GetEnum<BloomFilterAlgorithm>(i))) {
      return false;
    }
  }
  return true;
}

inline bool VerifyBloomFilterHash(flatbuffers::Verifier &verifier, const void *obj, BloomFilterHash type) {
  switch (type) {
    case BloomFilterHash_NONE: {
      return true;
    }
    case BloomFilterHash_XxHash: {
      auto ptr = reinterpret_cast<const parquet2::XxHash *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyBloomFilterHashVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyBloomFilterHash(
        verifier,  values->Get(i), types->GetEnum<BloomFilterHash>(i))) {
      return false;
    }
  }
  return true;
}

inline bool VerifyBloomFilterCompression(flatbuffers::Verifier &verifier, const void *obj, BloomFilterCompression type) {
  switch (type) {
    case BloomFilterCompression_NONE: {
      return true;
    }
    case BloomFilterCompression_Uncompressed: {
      auto ptr = reinterpret_cast<const parquet2::Uncompressed *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyBloomFilterCompressionVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyBloomFilterCompression(
        verifier,  values->Get(i), types->GetEnum<BloomFilterCompression>(i))) {
      return false;
    }
  }
  return true;
}

inline bool VerifyColumnCryptoMetadata(flatbuffers::Verifier &verifier, const void *obj, ColumnCryptoMetadata type) {
  switch (type) {
    case ColumnCryptoMetadata_NONE: {
      return true;
    }
    case ColumnCryptoMetadata_EncryptionWithFooterKey: {
      auto ptr = reinterpret_cast<const parquet2::EncryptionWithFooterKey *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ColumnCryptoMetadata_EncryptionWithColumnKey: {
      auto ptr = reinterpret_cast<const parquet2::EncryptionWithColumnKey *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyColumnCryptoMetadataVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyColumnCryptoMetadata(
        verifier,  values->Get(i), types->GetEnum<ColumnCryptoMetadata>(i))) {
      return false;
    }
  }
  return true;
}

inline bool VerifyColumnOrder(flatbuffers::Verifier &verifier, const void *obj, ColumnOrder type) {
  switch (type) {
    case ColumnOrder_NONE: {
      return true;
    }
    case ColumnOrder_TypeDefinedOrder: {
      auto ptr = reinterpret_cast<const parquet2::TypeDefinedOrder *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyColumnOrderVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyColumnOrder(
        verifier,  values->Get(i), types->GetEnum<ColumnOrder>(i))) {
      return false;
    }
  }
  return true;
}

inline bool VerifyEncryptionAlgorithm(flatbuffers::Verifier &verifier, const void *obj, EncryptionAlgorithm type) {
  switch (type) {
    case EncryptionAlgorithm_NONE: {
      return true;
    }
    case EncryptionAlgorithm_AesGcmV1: {
      auto ptr = reinterpret_cast<const parquet2::AesGcmV1 *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case EncryptionAlgorithm_AesGcmCtrV1: {
      auto ptr = reinterpret_cast<const parquet2::AesGcmCtrV1 *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyEncryptionAlgorithmVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyEncryptionAlgorithm(
        verifier,  values->Get(i), types->GetEnum<EncryptionAlgorithm>(i))) {
      return false;
    }
  }
  return true;
}

inline const parquet2::FileMetaData *GetFileMetaData(const void *buf) {
  return flatbuffers::GetRoot<parquet2::FileMetaData>(buf);
}

inline const parquet2::FileMetaData *GetSizePrefixedFileMetaData(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<parquet2::FileMetaData>(buf);
}

inline bool VerifyFileMetaDataBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<parquet2::FileMetaData>(nullptr);
}

inline bool VerifySizePrefixedFileMetaDataBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<parquet2::FileMetaData>(nullptr);
}

inline void FinishFileMetaDataBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<parquet2::FileMetaData> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedFileMetaDataBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<parquet2::FileMetaData> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace parquet2

#endif  // FLATBUFFERS_GENERATED_FLATBUFFNS_PARQUET2_H_
